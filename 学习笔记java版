Android学习笔记
一、基础部分
    1、日志工具使用 ：用于打印重要信息
        1】常用的五种使用方式 ：
            1-- Log.v(tag:str, meg:str) : 第一个参数为过滤信息第二个为打印内容，对应级别verbose，优先级最低,用以打印最为琐碎的、意义最小的日志信息。
            2-- Log.d(tag:str, meg:str) : 第一个参数为过滤信息第二个为打印内容，对应级别debug，优先级比verbose高，打印调试信息
            3-- Log.i(tag:str, meg:str) : 第一个参数为过滤信息第二个为打印内容，对应级别info，优先级比debug高，打印重要的数据
            4-- Log.w(tag:str, meg:str) : 第一个参数为过滤信息第二个为打印内容，对应级别warn，优先级比info高，打印警告信息
            5-- Log.e(tag:str, meg:str) : 第一个参数为过滤信息第二个为打印内容，对应级别error，优先级比warn高，打印错误信息
        2】设置过滤选项 ：从日志中过滤出有用信息
            最下方左侧展示框中的 logcat 选项栏，可设置优先级以及类型，设置优先级是设定显示的最低优先级
二、活动 ：Activity
    1、什么是活动
        一个活动包含多个控件，它是应用的一个屏显示内容
    2、活动的基本用法
        1】创建新活动 ：
            1-- 进入project模式，进入app->src->main->java->com.example.activitytest
            2-- 右键com.example.activitytest，选择New->Activity->需要创建的活动类型
              两个复选框 ：（第一次创建时未选择，下面为手动配置过程）
                Generate Layout File : 创建一个对应布局文件
                Launcher Activity : 设置此活动为当前项目主活动
        2】创建和加载布局
            创建布局 ：
            1-- 在app->src->main->res下创建一个名为layout的目录，用以存放layout布局文件
                    右键 res ，New->Directory
            2-- 右键layout，New->Android Resource File ,创建布局文件
            加载布局 ：
            1-- setContentView(layout_id);  //为活动加载布局文件
        3】在AndroidManifest文件中注册
            1-- 普通注册 ：
                <activity android:name=".FirstActivity"></activity>  只需要注册通过android:name设置活动名称
                         .FirstActivity ：com.example.activitytest.FirstActivity的缩写
            2-- 注册为主活动 ：
                <activity android:name=".FirstActivity"
                            android:label="Demo">   //添加标题，活动最上部显示内容
                            <intent-filter>
                                <action android:name="android.intent.action.MAIN"/>
                                <category android:name="android.intent.category.LAUNCHER" />
                            </intent-filter>
                        </activity>

    3、活动中使用Toast ：用以显示短小的信息，这些信息将在一段时间后自动消失
        1-- 语法 ：
            Toast.makeText(Context, meg:string, time).show();
                1-  Context : 上下文对象
                2- meg ：显示的主题，字符串
                3- time ：显示时长，可选参数--Toast.LENGTH_SHORT、Toast.LENGTH_LONG

    4、在活动中使用Menu ：适用于有很多菜单需要显示的情况
        1-- 使用流程
            1- 在res下新建一个Directory,命名为mnue，在其中新建一个Android Resource File，命名为main
            2- 添加 <item> 标签来创建一个具体的菜单项，android:id 设置标识符， android:title 设置菜单项名称
            3- 回到活动的.java文件中重写 onCreateOptionsMenu()方法，如下 ：
                @Override
                    public boolean onCreateOptionsMenu(Menu menu) {
                        getMenuInflater().inflate(R.menu.main, menu);
                        return true;
                    }
                getMenuInflater() ：得到MenuInflater对象
                inflate() ：给当前活动创建菜单，第一个参数为id标识符，用于指定菜单资源文件；第二个为被添加菜单的对象，此处使用传回来的对象。
                返回值表示是否允许显示菜单，true为允许

        2-- 获取菜单选择的内容
            重写 onOptionsItemSelected() ,示例代码如下 ：
                public boolean onOptionsItemSelected(@NonNull MenuItem item) {
                        switch(item.getItemId()) {
                            case R.id.add_item :
                                Toast.makeText(this, "Add", Toast.LENGTH_SHORT).show();
                                break;
                            case R.id.remove_item :
                                Toast.makeText(this, "Remove", Toast.LENGTH_SHORT).show();
                                break;
                            default:
                        }
                        return true;
                    }
                此处用id来进行判断，getItemId（）--获取被选中item的id，返回值为true表示显示菜单
        3-- 调用setContentView(layout_id) 显示布局文件
            切换
    5、销毁一个活动
        调用finish()方法即可

    6、使用Intent在活动见传递数据
        1】关于Intent ：
            Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。
          Intent 一般可被用于启动活动、启动服务以及发送广播等场景。
        2】分类 ：
            1-- 显式 Intent 使用方法：
              【*】明确指明要启动的活动
                1- 构造函数 ：Intent(Context packageContext, Class<?>)
                    第一个参数 ：启动活动的上下文对象（注意：不是被启动对象），例如 ：FirstActivity.this
                    第二个参数 ：被启动活动的类，例 ：SecondActivity.class
                2- 调用 startActivity(intent) : 打开一个活动
                    参数为Intent对象
                3- 历程 ：
                    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);  //创建Intent对象
                    startActivity(intent);  //开启另一个活动
            2-- 隐式 Intent 使用方法：
              【*】不明确指明要开启的活动，只是指明一系列抽象的action和category等信息，然后交由系统去分析找出合适的活动起动
                1- 合适的活动 ：可以响应我们这个隐式Intent的活动
                2- 一个活动可以设置多个category，但只能设定一个action，匹配是需要匹配所有的 action、category，
                3- 示例 ：
                    活动注册配置文件 ：
                         <activity android:name=".SecondActivity">
                            <intent-filter>
                                <action android:name="com.example.activitytest.ACTION_START" />
                                <category android:name="android.intent.category.DEFAULT" />
                                <category android:name="com.example.activitytest.MY_CATEGORY" />
                            </intent-filter>
                         </activity>

                    .java文件中 ：
                        Intent intent = new Intent("com.example.activitytest.ACTION_START");
                        intent.addCategory("com.example.activitytest.MY_CATEGORY");
                        startActivity(intent);
                      初始化时参数为action的匹配型，addCategory()为添加category，可添加多个
                      android.intent.category.DEFAULT为category的默认值，设定为这个可以不用添加
                4- 更多隐式Intent的用法 ：可以启动别的程序中的活动
                    1]示例 ：点击按钮用浏览器访问某网站
                        Intent intent = new Intent(Intent.ACTION_VIEW);
                        intent.setData(Uri.parse("http://www.baidu.com"));
                        startActivity(intent);
                      Intent.ACTION_VIEW : Android的内部动作，其常量值为 ：android.intent.action.VIEW
                      Uri.parse(string) ：将内容解析为uri对象
                      setData ：将Uri对象传递进去，指定当前Intent正在操作的对象，只能接受Uri对象
                    2]我们还可以在<intent-filter>标签中在配置一个<data>标签，用来精确指定当前活动能够影响的数据类型 ：
                        可配置选项 ：
                            android:scheme ：用于指定数据的协议部分，例如 ：http
                            android:host ：用于指定数据的主机名部分，例如 ：www.baidu.com
                            android:port ：用于指定数据的端口部分，一般紧随主机名之后，例如 ：8080
                            android:path ：用于指定主机名和端口之后的部分，如一段网址或域名之后的东西
                            android:mimeType ：用于指定可以处理的数据类型，允许使用通配符进行指定。
                        只有当<data>标签与Intent中的Data一致时当前活动才能够响应该Intent，不建议设置太多的限制项，
                      例如上述例子只需要设置协议为http即可
                    3]如果匹配到多个可响应活动，会议列表的形式展示，选择合适的一项即可
                   【*】除了http外还可以指定其他协议 ：
                        geo ：显示地理位置
                        tel ：表示拨打电话，调用示例 ：intent.setData(Uri.parse("tel:10086"));

    7、向下一个活动传递数据
        1】流程 ：
            创建Intent对象 -> 将数据暂存在Intent中 -> 利用Intent开启下一个活动 -> 取出数据
        2】暂存数据 ：putExtra()方法
            putExtra(key, value) : 第一个参数为键，第二个为传递的数据
        3】示例 ：
            发送方 ：
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                intent.putExtra("data", "GOOD");  //以键值对的形式暂存
                startActivity(intent);
            接收方 ：
                Intent intent = getIntent();  //获取启动此活动的Intent
                String string = intent.getStringExtra("data");  //获取键对应的数据，不同类型的数据对应不同的方法，例：getIntExtra()获取整形数据

    8】返回数据给上一个活动
        1】启动活动 ：用startActivityForResult()方法来启动，此方法会在活动销毁时返回一个结果给上一个活动
            参数1 ：Intent对象
            参数2 ：请求码，用于在回调中判断数据的来源
        2】相关方法 ：
            startActivityForResult(Intent, 请求码(int)) ；用来打开活动，用此方法启动活动可以接收被启动活动返回的数据
            setResult(返回结果, Intent) : 用于返回数据给上一个活动，参数1常用值：RESULT_OK、RESULT_CANCELED
            onActivityResult(requestCode, resultCode, data) : 在上一个活动中重写，回调此函数来接收返回的数据
                参数1-requestCode ：启动活动时传入的请求码
                参数2-resultCode ：返回数据时传入的返回结果
                参数3-data ：携带返回数据的Intent
               【*】由于在一个活动中有可能调用startActivityForResult()方法去启动很多不同的活动,每一个活动返回的数据都会回调到onActivityResult()这
                 个方法中，因此我们首先要做的就是通过检查requestCode的值来判断数据来源。确定数据是从SecondActivity返回的之后,我们再通过
                 resultCode的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作。
        3】示例 ：
            启动活动 ：
                启动活动部分：可携带数据启动，方法和上述一致，注意启动方法差异即可
                    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                    startActivityForResult(intent, 1);
                接收返回数据部分：
                     @Override
                    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
                        super.onActivityResult(requestCode, resultCode, data);  //注意此句不可删除
                        switch (requestCode) {  //判断请求码
                            case 1:
                                if (resultCode == RESULT_OK) {  //判断返回状态
                                    String string = data.getStringExtra("first");  //提取数据
                                    Toast.makeText(this, string, Toast.LENGTH_SHORT).show();  //显示
                                }
                                break;
                            default:
                        }
                    }
            被启动活动 ：
                Intent intent = new Intent();  //创建Intent对象用来暂存数据
                intent.putExtra("first", "Android Studio");  //暂存数据
                setResult(RESULT_OK, intent);  //返回带有数据的Intent
                finish();  //结束活动
              上述代码是利用按钮点击来完成参数传递，如果直接按返回键则无法用调用上述部分，此时可以重写onBackPressed()方法
            其他部分和上述相同，按下返回键会调用onBackPressed()方法
    8、活动的生命周期
        1】返回栈
            1）定义 ：Android的活动是使用任务(Task)来管理的，一个任务就是一组存放在栈里活动的集合，这个栈就是返回栈
                栈 ：栈是一种先入后出的数据结构
            2）活动与栈 ：我们每启动一个新活动，他就会进入返回栈中，并且处于栈顶的位置，当我们销毁活动或按下back时，处于栈顶的活动就会出栈，前一个入栈的活动就会处于栈顶
                      系统总是会显示处于栈顶的活动。
        2】活动状态 ：
            1）运行状态 ：活动处于栈顶的状态
            2）暂停状态 ：不在处于栈顶，但仍可见（并不是每一个活动都需要占满整个屏幕，某些活动只会占用一部分屏幕，但不处于栈顶了，处于此状态的活动那个仍然存活）
            3）停止状态 ：当一个活动不再处于栈顶且完全不可见时，系统仍会为这种活动保存相关的状态和成员变量，但不可靠，这部分内存可能会被占用
            4）销毁状态 ：从返回栈中移除后，系统会回收此状态活动的内存
        3】活动的生命周期 ：
            1）onCreate() ：此方法会在活动第一次被创建的时候被调用，它完成活动的初始化，例如：布局加载、绑定事件
            2）onStart() ：在活动由不可见变为可见时被调用
            3）onResume() ：在活动准备好和用户进行交互时被调用，此活动一定处于栈顶，并且处于运行状态
            4）onPause() ：系统准备去启动或者恢复另一个活动时被调用，我会通常会将一些消耗CPU的资源释放掉，以及保存关键数据(这个方法执行的速度一定要快，否则会影响新的栈顶活动)
            5）onStop() ：在活动完全不可见时调用，它和onPause()的区别在于如果启动的新活动是一个对话框式的活动，那么onPause() 方法会得到执行，而onStop()方法并不会执行。
            6）onDestroy() ：在活动被销毁前调用，之后互动会变为销毁状态
            7）onRestart() ：在活动由停止状态变为运行状态之前调用（活动被重新启动）
          完整生存期 ：活动在onCreate()和onStop()之间经历的就是完整生存期。活动会在onCreate()完成初始化，在onDestroy()中完成释放内存
          可见生存期 ：活动在onStart()和onStop()之间经历的就是可见生存期，在这一阶段，活动总是可见的，即便可能无法与用户进行交互。我们可以在
                onStart()进行资源加载，在onStop()进行资源释放。
          前台生存期 ：活动在onResume()和onPause()之间经历的就是前台生存期。在此期间，活动总处于运行状态，此时活动可以与用户进行交互。
        4】体验活动的生命周期 ：
            1）打开活动的生命周期 ：
                onCreate -> onStart -> onResume -中途开启其他活动-> onPause -> onStop -关闭开启的活动-> onRestart -> onStart -> onResume -关闭此活动-> onPause -> onStop -> onDestroy
            2）打开对话框的生命周期 ：
                onCreate -> onStart -> onResume -中途开启对话框-> onPause  -关闭开启的对话框-> onResume -关闭此活动-> onPause -> onStop -> onDestroy
        5】活动的回收机制 ：
            1）当你在活动A下启动活动B时，活动A处于停止状态，由于内存不足，活动A被回收，此时你按下Back返回到活动A，你执行的不是onRestart，而是onCreate，现在的活动A时重新创建的活动A，
            之前所输入的临时信息会被抹除。
            2）(重写)onSaveInstanceState() ：此方法会保证在活动被回收前一定会被调用，可以解决上述问题，onSaveInstanceState()会携带一个Bundle类型的参数
                Bundle中提供了很多方法用来保存数据 ：
                    保存整形 ：putInt(key,value)
                    保存字符串 ：putString(key,value)
            3）使用方法 ：
                1-- 通过onSaveInstanceState()将需要保存的数据保存 -> 如果被回收则通过onCreate()方法的savedInstanceState参数进行复原
              【*】进行复原之前需要进行非空判断 --- 判断savedInstanceState是否非空
                2-- 通过savedInstanceState的getString(key)、getInt(key)等方法来获取保存的数据
                3-- 恢复到相应位置
            4）小知识 ：
                Bundle 可与 Intent 联合使用 ：将数据保存至Bundle，然后将Bundle绑定至Intent，然后再被启动活动中获取Intent，最后提取出Bundle
    9、活动的启动模式 ：
        活动的启动模式可以在AndroidManifest.xml中通过给<activity>标签指定android:launchMode属性来设置
        1】standard 启动模式
            1）此方式是活动的默认启动方式，再不进行显示指定的情况下，所有活动都会按照此方式启动，再次方式下，每启动一个活动就会入栈处于栈顶的位置，
            它不在乎这个活动是否已经处于栈顶（不在乎是否已经启动了此活动），每次都会创建一个新的实例。
            2）示例 ：活动重复启动它自己
                    start_normal.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent(FirstActivity.this, FirstActivity.class);
                        startActivity(intent);
                    }
                });
        2】singleTop 启动模式
            1）简介 ：当活动被启动时，如果发现自己处于返回栈栈顶，则认为可以直接使用它，不会创建新的实例
            2）示例 ：
                注册配置 ：android:launchMode="singleTop"
                .java文件和正常启动相同
            3）注意 ：如果你在活动A(启动模式为singleTop)启动活动B，然后在活动B中启动活动A，他会创建一个活动A的实例，但是这个活动A与前一个活动A不是同一个，此时你的返回栈中有两个活动A
        3】singleTask 启动模式
            1）简介 ：当需要启动活动时，他会在栈内检查是否存在该活动实例，如果有，则将它上面的活动全部出栈，然后使它置于栈顶如果没有就创建一个新的实例
            2）使用时配置launchMode属性即可
        4】singleInstance 启动模式（此方式最复杂）
            1）简介 ：此模式下的活动在启动时会创建一个新的返回栈来管理这个活动（如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。
                这种模式适用于一个活动允许被其他程序调用，其他的程序可以共享此活动。每个应用程序都有自己的返回栈，同一个活动在进入不同栈时会创建新的实例，
                使用此模式可以实现其他应用程序访问这个活动时公用同一个返回栈，实现了共享活动实例。
            2）使用时设定对应模式即可
    10、活动的使用
        1】获取当前活动
            在包com.example.activitytest中新建一个java类，名称自定义此处为BaseActivity，然后继承至AppCompatActivity，重写onCreate方法，在其中加入
          Log.d("BaseActivity", getClass().getSimpleName()); 此句会获取并在日志中打印当前活动的类名，然后让其他的java类继承BaseActivity，这样也不会影响其他的功能
        2】随时随地退出
            创建一个专门的集合类去对所有的活动进行管理，在其中添加对应的活动管理方法
          1）实现流程 ：
            1-- 创建集合管理类 ：ActivityCollector
            2-- 在这个集合类中编写相关方法，具体参考对于.java文件
            3-- 为了保证程序完全退出，在调用销毁所有活动后添加一句杀掉当前进程的代码，如下 ：
                android.os.Process.killProcess(android.os.Process.myPid());
            2）示例 ：
                关闭部分代码 ：
                    ActivityCollector.finishAll();  //关闭所有活动
                    android.os.Process.killProcess(android.os.Process.myPid());  //关闭当前程序进程
        3】启动活动的最佳写法
            编写一个独立的启动方法(函数)，例如 ：
                假设需要启动 SecondActivity 活动，需要两个参数，最佳写法如下 ：
                    1-- 在 SecondActivity 中添加一个actionStart的方法
                    2-- 在此方法中完成Intent的创建，所有SecondActivity需要的参数都是通过actionStart方法传递过来的，
                    3-- 将数据存储到Intent中
                    4-- 最后调用SecondActivity的actionStart方法

三、UI界面编写
    1、基础控件
        1】TextView : 文本展示框
            1）简介 ：用于在屏幕上展示文本信息
            3）常用属性 ：
                1-- android:id : 定义唯一标识符
                2-- android:layout_width : 设置控件宽度
                3-- android:layout_height : 设置控件高度
                    （2和3的可选属性 ：match_parent、fill_parent、wrap_content）
                    match_parent ：与父容器相同（和一样fill_parent）
                    wrap_content ：当前大小刚好能包裹住内容
                    也可以指定固定大小（单位dp）
                4-- android:text : 设置显示文本
                5-- android:gravity ：设置文字对齐方式（内部），可选值有top\bottom\left\right\center,可用‘|’指定多个值
                6-- android:textSize ：设置文字大小（单位sp）
                7-- android:textColor ：设置文字颜色
        2】Button ：单击按钮
            1）简介 ：用来与用户交互，可被点击
            2）常用功能 ：
                1-- android:textAllCaps ：设置自动字母大小写转换（true为允许，false为拒绝）
                2-- setOnClickListener() ：点击事件监听器，被单击时调用
                    语法1 ：使用匿名类方法
                        start_normal.setOnClickListener(new View.OnClickListener() {
                            @Override
                            public void onClick(View v) {
                            }
                        });
                    语法2 ：使用接口的方式
                        start_normal.setOnClickListener(this);
                        @Override
                        public void onClick(View v) {

                        }
        3】EditText ：文本编辑框
            1）简介 ：常用的交互控件，可以输入编辑
            2）常用方法 ：
                1-- android:hint ：占位提示符，一段提示文本，用户输入信息后会消失
                2-- android:maxLines : 设置最大行数，文本框能同时显示的最大行数，超过两行就会向上滚动
                3-- getText() ：获取编辑框文本内容(需要使用toString()方法转换为字符串)
        4】ImageView ：图片视图
            1）简介 ：用于在界面上展示图片
            2）常用方法 ：
                1-- android:src : 设置被显示的图片资源（参数语法 ："@路径/名称"）
                2-- setImageResource(R.路径.名称) ：设置图片资源（java代码）
        5】ProgressBar ：进度条（默认为旋转进度条）
            1）简介 ：用于在界面上显示一个进度条
            2）常用方法：
                1-- android:visibility ：设置控件是否可见（所有控件都有），可选参数 ：
                    visible ：控件可见（默认值）
                    invisible ：控件不可见，任然占有原来的位置
                    gone ：控件不可见，不占用屏幕
                2-- setvisibility() : 设置控件是否可见（所有控件都有；java），可选参数 ：
                    View.VISIBLE ：控件可见（默认值）
                    View.INVISIBLE ：控件不可见，任然占有原来的位置
                    View.GONE ：控件不可见，不占用屏幕
                3-- style : 设置样式
                    参数可选项1 ：style="?android:attr/progressBarStyleHorizontal" 设置为水平进度条
                4-- android:max : 设置最大值（水平进度条时使用）
                5-- android:progress : 设置当前进度
                6-- setProgress() : 设置当前进度(java)
        6】AlertDialog ：对话框
            1）简介 ：弹出对话框，置顶在所有界面元素之上，提示重要信息（模态）
            2）常用方法：
                1-- 创建对象 ：AlertDialog.Builder dialog = new AlertDialog.Builder (MainActivity. this);
                2-- 设置标题 ：dialog.setTitle("This is Dialog");
                3-- 设置提示信息 ：dialog.setMessage("Something important");
                4-- 设置是否可被取消（按返回键取消） ：dialog.setCancelable(false); false--不可被取消
                5-- 添加按钮 ：
                   1- 设置对话框确定按钮 :
                        dialog.setPositiveButton("OK", new Dialoginterface.
                        OnClickListener() {
                            ©Override
                            public void onClick(Dialoginterface dialog, int which) {
                             } })；
                            第一个参数 ：确定按钮的文本
                            第二个参数 ：按钮点击事件监听器
                   2- 设置对话框取消按钮 :
                       dialog.setNegativeButton("Cancel", new Dialoginterface.
                       OnClickListener() {
                           ©Override
                           public void onClick(Dialoginterface dialog, int which) {
                            } })；
                           第一个参数 ：确定按钮的文本
                           第二个参数 ：按钮点击事件监听器
               6-- 显示对话框 ：dialog.show();
        7】ProgressDialog ：进度条对话框
            1）简介 ：弹出对话框，置顶在所有界面元素之上，显示一个旋转滚动条和提示信息（模态）
            2）常用方法：
                1-- 创建对象 ：ProgressDialog progressDialog = new ProgressDialog (MainActivity.this);
                2-- 设置标题 ：progressDialog.setTitle("This is ProgressDialog");
                3-- 设置提示信息 ：progressDialog.setMessage("Loading. ..");
                4-- 设置是否可被取消（按返回键取消）：progressDialog.setCancelable(true);  true :可被取消
                5-- 显示对话框 ：progressDialog.show();
                6-- 关闭对话框 ：progressDialog.dismiss();

    2、四种基本布局
        1】线性布局 ：LinearLayout
            1）简介 ：此布局中的控件会排列在水平或垂直的方向上(通过参数设置)确定一个排列方向
            2）常用方法 ：
                1-- android:orientation : 设置布局方向，可选参数：1 vertical--垂直方向；2 horizontal--水平方向（默认值）
                    注意 ：LinearLayout 的排列方向设置为 horizontal,就不能将控件宽度指定为match_parent；排列方向设置为 vertical,就不能将控件高度指定为 match_parent
                2-- android:layout_gravity : 指定控件在布局中的对齐方式
                    注意 ：当 LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效；当 LinearLayout 的 排列方向是 vertical 时，只有水平方向上的对齐方式才会生效
                3-- android:layout_width ：设置控件宽度
                4-- android:layout_weight : 按比例分配宽度（使用此方法是必须将android:layout_width设置为0dp,并且时垂直布局）
                    注意 ：单位dp---用于指定控件大小、间距等属性的单位
        2】相对布局 ：RelativeLayout
            1）简介 ：通过相对定位的方式进行控件布局，对一个控件进行定位时，需要一个参考控件，然后相对这个参考控件来定位
                    注意 ：相对布局不会强制定位在正方向上，只是相对的，需要对齐方式来调整，例如：
                      当你将控件A采用相对布局定位到控件B的左边，A不会在B的正左方，而是左上或左下。
            2）常用方法 ：
                1-- android:layout_alignParentLeft ：紧贴父容器左边界
                2-- android:layout_alignParentTop ：紧贴父容器上边界
                3-- android:layout_alignParentRight ：紧贴父容器右边界
                4-- android:layout_alignParentBottom ：紧贴父容器下边界
                5-- android:layout_centerInParent ：处于父容器中心
                    注意 ：上述几个可以设置多个，实现左上角、右下角等等
                6-- android:layout_above ：位于指定控件的上方（参数 ：@id/指定控件id ）
                7-- android:layout_below ：位于指定控件的下方（参数 ：@id/指定控件id ）
                8-- android:layout_toLeftOf ：位于指定控件的左方（参数 ：@id/指定控件id ）
                9-- android:layout_toRightOf ：位于指定控件的右方（参数 ：@id/指定控件id ）
                10-- android:layout_alignLeft : 与指定控件左侧紧贴（参数：@id/指定控件id）
                11-- android:layout_alignRight : 与指定控件右侧紧贴（参数：@id/指定控件id）
                12-- android:layout_alignTop : 与指定控件上方紧贴（参数：@id/指定控件id）
                13-- android:layout_alignBottom : 与指定控件下方紧贴（参数：@id/指定控件id）
        3】帧布局 ：FrameLayout
            1）简介 ：所有的控件都会默认摆放在布局的左上角，后放置的控件处于最上层
            2）常用方法 ：
                可以在控件内使用android:layout_gravity设置对齐方式
        4】百分比布局（此布局为新增布局）-- 测试失败，不允与考虑
            1）简介 ：在此布局中，我们可以直接指定控件在布局中所占的百分比，实现任意比例分割，百分比布局只是在相对布局与帧布局基础上进行了拓展
                提供了PercentFrameLayout和PercentRelativeLayout这两个全新布局
            2）使用方式 ：Android 团队将百分比布局定义在了support库当中，我们只需要在项目的build.gradle 中添加百分比布局库的依赖，就能保证
                    百分比布局在 Android 所有系统版本上的兼容性了。

    3、创建自定义控件
                                控件的继承树
                                   View
                TextView         ImageView          ViewGroup
          EditText    Button                    LinearLayout  RelativeLayout  。。。

        1】引入布局 ：可以将页面的重复元素单独编写，避免代码重复
            在XML文件中引入布局（此段为添加标题栏，代码在title布局文件中） ：
                语法 ：<include layout="@路径/布局文件名" /> ，例 ：
                    <include layout="@layout/title" />
            需要将默认的标题栏屏蔽 ：
                ActionBar actionBar = getSupportActionBar();
                if (actionBar != null) {
                    actionBar.hide();
                }
        2】创建自定义控件
          当引入的布局需要事件响应且在不同界面中该控件的功能都想同时，使用自定义控件解决
            1）创建一个xml的布局文件，为自定义控件布局，此处演示为：title.xml
            2）编写一个java文件与自定义控件的布局文件绑定 ：
                public class TitleLayout extends LinearLayout {
                    public TitleLayout(Context context, AttributeSet attrs) {
                        super(context, attrs);
                        LayoutInflater.from(context).inflate(R.layout.title, this);
                    }
                }
                LayoutInflater.from(context).inflate(R.layout.title, this); 对自定义控件进行动态加载
                    LayoutInflater.from(context) ：构建一个LayoutInflater对象
                    inflate(R.layout.title, this) ：动态加载布局文件。参数1 ：布局文件；参数2 ：给加载好的布局添加一个父布局
              java类和布局文件名称最好对应
            3）在需要添加自定义控件的布局中添加自定义控件
                与普通控件基本一致，但是需要完整的包名
                <com.example.activitytest.TitleLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content" />
            4）为自定义控件添加事件:
                与普通的事件添加基本一致,参考对应代码即可（TitleLayout.java）
    4、ListView ：列表视图
       简介 ：列表视图是将一系列展示内容采用一项一行的方式排列（类似微信联系人列表）
        1】简单用法 ：
            1）在布局文件中添加控件，设置好ID、大小等属性
            2）定义数组对象保存内容
                    private String[] data =new String[]{"Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango", "Apple", "Banana",
                                                "0range", "Watermelon","Pear","Grape", "Pineapple", "Strawberry", "Cherry"};
            3）创建适配器对象并初始化，初始化过程会添加数据
                    ArrayAdapter<String> adapter = new ArrayAdapter<String>(FirstActivity.this,
                                    android.R.layout.simple_list_item_1, data);  //创建适配器并初始化
                    参数1 ：上下文对象
                    参数2 ：listView子项的ID（内置）
                    参数3 ：传递数据对象
            4）获取列表视图对象并绑定适配器
                    ListView listView = findViewById(R.id.list);
                    listView.setAdapter(adapter);

        2】定制ListView界面
          默认的listView只能显示一行文本，比较单调，可以参考以下方式自定义
         【*】此定制效果为文本旁有一个图标
            1）定义一个实体类作为ListView适配器的适配类型（此处命名为Fruit） : 代码参考 Fruit.java
            2）为ListView子项指定我们自定义的布局，新建一个xml文件去编辑自定义布局  ：代码参考 fruit_item.xml
            3）创建一个自定义适配器，这个适配器继承至ArrayAdapter，将泛型指定为Fruit类，此适配器名称定为 ：FruitAdaper，代码参考 ：FruitAdaper.java
              关键语句 ：
                /*此方法用于加载子项，参数依次为
                 **子项id、父容器、boolen ：false的含义--只让我们在父布局中声明的 layout 属性生效，但不为 这个 View 添加父布局
                 * ，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了，false为标准写法*/
                 view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
            4）优化ListView的运行效率 ：
                在上述过程实现后，每次getView方法都会把布局重新加载一遍，它还有一个convertView参数，用于将之前加载好的布局进行缓存，方便重用，修改参考 ：FruitAdaper.java
                优化1 ：实现了getView不会每一次都重新加载布局
                优化2 ：实现了当View存在时不必允许findViewById去获取控件
        3】ListView的点击事件
            项目点击事件监听器 ：setOnItemClickListener
                listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
                @Override
                public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                    Fruit fruit = fruitList.get(position);  //获取被点击的子项
                    Toast.makeText(FirstActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();
                    }
                });

    5、滚动视图 ；RecyclerView
        1】基本用法 ：
            1）在build.gradle(:app)文件中添加滚动试图的依赖 ：
                //noinspection GradleCompatible
                implementation 'com.android.support:recyclerview-v7:28.0.0'
            2）在布局文件中添加控件，注意是完整路径，配置ID、大小等尺寸
            3）配置适配器 ：参考RecyFruitAdaper.java文件

        2】实现横向滚动
            1）首先是对子项布局进行修改 ：参考app\view_notes\RecyclerView横向滚动 "三、子项布局"
                将布局设置为垂直布局，宽度设置为100dp防止宽度不一
                将两个控件设置为在布局中水平居中
            2）将默认的水平排列设置为水平排列（滚动方向） ：
                layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);  //设置为水平排列
        3】瀑布流布局 ：参考app\view_notes\RecyclerView瀑布流布局
            1）对子类布局进行微调 ：
            2）创建并初始化布局对象 ：参考app\view_notes\RecyclerView瀑布流布局 "二、子项布局"
                StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);  //创建StaggeredGridLayoutManager对象
                    参数一 ：指定布局的列数，设定后布局会进行平分
                    参数二 ：用于指定布局的排列方式，StaggeredGridLayoutManager.VERTICAL 表示垂直排列
            3）设置各个子项的高度不一致 ：
                    使文本长度不一样，此处为使重复名称
        4】RecyclerView 的点击事件
            1）简介 ：RecyclerView 的点击事件需要我们给子项具体的View注册点击事件
            2）实现流程 ：
                1-- 修改ViewHolder，在其中加入fruitView变量来保存子项最外层布局实例
                    View fruitView;  ////子项View全局变量定义，用于设置点击事件
                2-- 在onCreateViewHolder中注册点击事件，历程注册了最外层布局和ImageView的点击事件
                    holder.fruitView.setOnClickListener(new View.OnClickListener() {  //设置子项最外层的点击事件
                        @Override
                        public void onClick(View v) {
                            int position = holder.getAdapterPosition();
                            Fruit fruit = mFruitList.get(position);
                            Toast.makeText(v.getContext(), "you clicked view" +fruit.getName(), Toast.LENGTH_SHORT).show();
                        }
                    });

                    holder.fruitImage.setOnClickListener(new View.OnClickListener() {  //设置子项图片视图的点击事件
                        @Override
                        public void onClick(View v) {
                            int position = holder.getAdapterPosition();
                            Fruit fruit = mFruitList.get(position);
                            Toast.makeText(v.getContext(), "you clicked view" +fruit.getName(), Toast.LENGTH_SHORT).show();
                        }
                    });
                3-- 在点击事件中获取用户点击的 position，然后通过position获取Fruit实例
                    int position = holder.getAdapterPosition();
                    Fruit fruit = mFruitList.get(position);
              【*】RecyclerView可以注册子项任意控件的点击事件

    6、RecyclerView 与 ListView比较
        ListView的布局排列是由自身去管理的,而 RecyclerView 则将这个工作交给了 LayoutManager, LayoutManager中制定了一套可扩展的布局
      排列接口，子类只需要按照接口的规范来实现即可，就能实现不同方式的布局
        RecyclerView的布局方式 ：LinearLayoutManager 、GridLayoutManager 、StaggeredGridLayoutManager
            GridLayoutManager ：网格布局
            StaggeredGridLayoutManager ：瀑布流布局

    7、界面编写小技巧
        1】制作-path图片
            1）简介 ：
                9-path图片是一类特殊处理过的图片，能够指定某些区域可以被拉伸，类似QQ消息框的伸缩变化
            2）制作 ：首先将需要制作的图片导入，然后右键它，选择 “Create p Path file” 然后拖动边线设定可拉伸区域
        2】编写聊天界面 ：
            1）聊天框背景采用9-path图片，可以适应拉升，同时，为了美观应该设定最大宽度，还需要设定内边距，使不可拉伸区域不会出现显示内容
            2）消息显示应该使用 recyclerview 来进行布局
            3）下方还应该有发送按钮、文本编辑区

四、碎片的学习
    1、碎片的含义
        1】碎片（Fragment）是一种可以嵌入在活动当中的 UI 片段，它能让程序更加合理和充分地利 用大屏幕的空间，因而在平板上应用得非常广泛。
        虽然碎片对你来说应该是个全新的概念，但我 相信你学习起来应该毫不费力，因为它和活动实在是太像了，同样都能包含布局，同样都有自己 的
        生命周期。你甚至可以将碎片理解成一个迷你型的活动，虽然这个迷你型的活动有可能和普通的活动是一样大的。
        2】将设备的屏幕分区，然后每一个小分区就是一个碎片，我们需要充分的使用屏幕上的碎片空间
    2、碎片的使用方式
        1】使用范围 ：通常是在平板开发中使用（平板为横屏，空间比较大，会有一些留白区域，这些区域就是碎片）
        2】使用流程 ：在布局文件中添加
            1）创建碎片的布局文件 ：此处为left_layout.xml 、 right_layout
            2）创建对应的java类 ，用来加载布局 ：此处为LeftFragment.java 、RightFragment.java
                重要语句 ：View view = inflater.inflate(R.layout.left_layout, container, false);  //加载布局
            3）在activity_main.xml（主布局文件中）添加<fragment>标签来添加碎片，不建议使用layout_width属性来设定宽度，建议使用layout_weight来设置宽度占比
                重要语句 ：android:name="com.example.table.RightFragment" 指明 碎片类名
    3、动态添加碎片 ：在程序运行过程中动态的添加到活动中
        1】创建步骤 ：
            1） 创建待添加碎片的实例 ：
                replaceFragment(new AnotherRightFragment()); 此方法的参数(new AnotherRightFragment())既为碎片实例
            2）获取FragmentManager，在活动中通过getSupportFragmentManager()方法获取
                FragmentManager fragmentManager = getSupportFragmentManager();
            3）开启一个事务，通过调用beginTransaction()实现
                FragmentTransaction transaction = fragmentManager.beginTransaction();
            4）像容器内添加或替换碎片，一般使用replace实现，传入容器的id和碎片实例
                transaction.replace(R.id.right_layout, fragment);
            5）提交事务，调用commit()方法实现
                transaction.commit();
    4、用碎片模拟返回栈
        1】简介 ：不使用返回栈时，按下back键会直接退出，使用后，按下back会返回上一个碎片
        2】使用方法 ：
            1）FragmentTransaction有一个addToBackStack()方法，用于将事务添加到返回栈中
            2）添加语句 ：
                transaction.addToBackStack(null);  //添加事务到返回栈，参数用于描述返回栈状态，一般用null
    5、碎片与活动之间的通信
        1】简介 ：碎片和活动都是存在于独立的类中，在碎片与活动进行通信时，FragmentManager提供了findFragmentById(),类似于findViewById()
        2】使用方法 ：
            在活动中获取碎片的实例 ：findFragmentById()
                RightFragment rightFragment = (RightFragment) fragmentManager.findFragmentById(R.id.right_fragment);  //获取碎片中的碎片实例
            在碎片中获取活动的实例 ：getActivity()
                MainActivity mainActivity = (MainActivity)getActivity();
    6、碎片的生命周期
        1】碎片的状态
            1）运行状态
                碎片可见，他所关联的活动正在运行
            2）暂停状态
                与碎片关联的活动处于暂停状态（另一个活动处于栈顶）
            3）停止状态
                当活动进入停止状态，他关联的碎片就会进入停止状态，或者调用FragmentTransaction的remove()、replace()方法将碎片移除，
              但是，如果事务提交了 addToBackStack方法，这时碎片也会进入停止状态（进入停止状态的碎片对用户完全不可见可能被销毁）
            4）销毁状态
                碎片依赖于活动，活动被销毁，碎片也会被销毁；通过调用FragmentTransaction的remove()、replace()方法将碎片移除，但在事务提交之前没有
              调用addToBackStack方法。
        2】碎片的回调方法
            1）活动有的碎片都有
            2）碎片特有的回调函数 ：
                1-- onAttach() ：碎片与活动建立关联时调用
                2-- onCreateView() ：为碎片创建视图（加载布局）时调用
                3-- onActivityCreated() ：确保与碎片相关联的活动一定已经创建完毕的时候调用
                4-- onDestroyView() ：当与碎片关联的视图被移除的时候调用
                5-- onDetach() ：当碎片和活动接触关联时调用

            3）回调函数允许流程图 ：
                onAttach -> onCreate -> onViewCreated -> onActivityCreated -> onStart -> onResume -按下Back退出-> onPause -> onStop -> onDestroyView -> onDestroy -> onDetach
    7、动态加载布局技巧
        1】使用限定符
            1）平板通常为双页模式，左侧显示子项列表，右侧为内容；但是手机有时双页有时单页，我们可以通过添加限定符（Qualifirers）来决定加载双页或单页布局
            2）示例流程 ：
                1-- 修改layout/activity_main.xml为单页，代码参考 ：layout/activity_main.xml
                2-- 创建layout-large文件夹，在其中创建activity_main.xml，代码参考 ：layout-large/activity_main.xml
                2-- large为限定符，将单页文件放置在layout中，双页文件放置在layout-large中，文件命名相同，这样可以方便切换单双页
            3）创建限定符参考 ：
              屏幕大小
                1-- small ：提供给小屏幕设备
                2-- normal ：提供给中等屏幕设备
                3-- large ：提供给大屏幕设备
                4-- xlarge ：提供给超大屏幕设备
              分辨率 ：
                1-- ldpi ：提供给低分辨率设备（120dpi以下）
                2-- mdpi ：提供给中等分辨率设备（120dpi~~160dpi）
                3-- hdpi ：提供给高分辨率设备（160dpi~~240dpi）
                4-- xhdpi ：提供给超高分辨率设备（240dpi~~320dpi）
                5-- xxhdpi ：提供给超超高分辨率设备（320dpi~~480dpi）
              方向 ;
                1-- land : 横屏设备
                2-- port ：竖屏设备
        2】使用最小宽度限定符
            1）简介 ：最小宽度限定符允许我们对屏幕宽度指定一个最小值（单位dp），然后以这个最小值为临界点，尺寸大于此值加载一个，小于加载另一个
            2）简单使用 ：
                1-- 在res目录下新建layout—sw600dp
                2-- 然后在文件夹新建activity_main.xml布局
              这就表示屏幕大于600dp时会加载layout—sw600dp/activity_main.xml，小于会加载layout/activity_main.xml

    8、碎片示例(rable moudle) ：简易的新闻应用(兼任手机和平板)
        1】创建News类，其中title表示新闻标题，content表示新闻内容
        2】新建布局文件 ：news_content_frag.xml,作为新闻布局
            分为两个部分 ：
                头部部分显示新闻标题，正文部分显示新闻内容，中间用一条细线隔开
        3】创建NewsContentFragment类用于加载布局
        4】创建一个新活动，踟蹰命名为NewsContentActivity，关联布局文件为news_content.xml，加载新闻内容
        5】创建显示新闻列表的布局，此处命名为 news_title_frag.xml
        6】创建子项布局，此处命名为 ：news_item.xml
            android:padding : 添加外边距
            android:singleLine="true" ：表示只能显示单行文本（以淘汰，可选择android:maxLines=""设置最大行数）
            android:ellipsize="end" ：设定文本超过空间宽度时的文本缩略方式，此为尾部缩略
        7】新建 NewsTitleFragment 作为展示新闻列表的控件，利用是否存在news_content_layout布局来选择单页还是双页
        8】在NewsTitleFragment新建一个内部类作为适配器，此处命名为NewsAdapter(此处为内部类，好处是可以直接访问内部变量)
        9】在NewsTitleFragment中添加RecyclerView（滚动视图）

五、广播学习
    1、广播简介
        1】分类
            1）标准广播 ：完全异步执行，发出后，所有接收器几乎同时接收到这条广播消息，没有先后顺序，无法被截断。
            2）有序广播 ：同步执行，发出后同一时刻只有一个接收器能接收到消息，当这个接收器中逻辑执行完之后，广播继续传递。在这个方式中，广播接收是有先后
                    顺序的，优先级高的接收器会优先接收广播消息，接收器还可以截断广播信息（后续接收器无法接收广播信息）
    2、接收系统广播
      android会内置很多系统级别的广播，我们在应用程序中监听这些广播来得到各种系统的状态信息
        1】动态注册监听网络变化
            1）广播接收器可以自定义注册(针对性注册),监听接收对于注册过的广播
            2）注册方式 ：
                1-- 在代码中注册 ：动态注册（可动态更改）
                2-- 在 AndroidManifest.xml 中注册 ：静态注册（程序运行状态不可更改）
            3）创建广播接收器 ：
                1-- 新建一个class，继承至 BroadcastReceiver
                2-- 重写父类onReceive()方法，每当有广播到来就会执行onReceive()方法
        2】使用广播来接收网络状态发生改变（动态注册）
            1）创建一个内部类继承至BroadcastReceiver，命名为 ：NetworkChangeReceiver
                private class NetworkChangeReceiver extends BroadcastReceiver
            2）为这个类重写 onReceive()方法，每当接收到注册的广播就会调用此方法
                @Override
                public void onReceive(Context context, Intent intent) {
                    Toast.makeText(context, "network changes", Toast.LENGTH_SHORT).show();
                }
            3）创建 IntentFilter 对象并添加action，当你注册一个广播时需要一个action，它代表你注册广播的头，用于过滤
                private IntentFilter intentFilter;  //全局变量
                intentFilter = new IntentFilter();
                intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");  //添加action（此处为网络状态发生改变）
            4）创建 NetworkChangeReceiver 实例
                private NetworkChangeReceiver networkChangeReceiver;
                networkChangeReceiver = new NetworkChangeReceiver();
            5）调用 registerReceiver() 方法进行注册，传入接收器实例和IntentFilter实例
                registerReceiver(networkChangeReceiver, intentFilter);  //注册广播
            5）注意点 ：动态注册的广播一定要取消注册
                unregisterReceiver(networkChangeReceiver);  //取消广播注册
          此部分只会提示网咯状态变化，但不会提示具体状态
        3】优化代码，获取网络状态
            1）优化代码如下（只对内部NetworkChangeReceiver类的onReceive()方法进行更改） ：
                @Override
                        public void onReceive(Context context, Intent intent) {
                            //获取 ConnectivityManager 实例（系统服务类，专门管理网络连接）
                            ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
                            //获取NetworkInfo实例
                            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
                            if (networkInfo != null && networkInfo.isAvailable()) {  //判断是否有网络
                                Toast.makeText(context, "net is available", Toast.LENGTH_SHORT).show();
                            } else {
                                Toast.makeText(context, "net is unavailable", Toast.LENGTH_SHORT).show();
                            }

                //            Toast.makeText(context, "network changes", Toast.LENGTH_SHORT).show();
                        }
            2）解读 ：
                1-- 获取 ConnectivityManager 实例（系统服务类，专门管理网络连接）
                    ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
                2-- 获取NetworkInfo实例，调用networkInfo.isAvailable()来判断是否有网络连接
                    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();  //获取实例
                    if (networkInfo != null && networkInfo.isAvailable()) {  //判断是否有网络
                        Toast.makeText(context, "net is available", Toast.LENGTH_SHORT).show();
                    } else {
                        Toast.makeText(context, "net is unavailable", Toast.LENGTH_SHORT).show();
                    }
            3）注意点 ：Android有保护用户设备安全和隐私的机制，规定 ：
                如果程序需要进行对用户来说比较敏感的操作，就必须配置文件中申明的权限，否则程序将崩溃。
               在上一个案例中我们访问系统的网络状态需要申明权限，下面是在AndroidManifest.xm中添加网络访问权限的代码 ：
                    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> (添加在<application>标签外，<manifest>标签内)
            4）动态注册优缺点
                动态注册的广播接收器可以自由控制注册于注销，但是它必须在程序启动之后才能接收到广播
        4】静态注册实现开机自启
            1）使用android studio提供的快捷方式来创建广播接收器
                1-- 右键 com.example.broadcast -> New ->Other ->Broadcast Receiver
                2-- 此处命名为 BootCompleteReceiver,创建时的两个属性 ：
                    Exported ：是否允许这个1广播接收器接收本程序以外的广播（建议勾选，具体看需求）
                    Enabled ：是否启动这个广播接收器（建议勾选，具体看需求）
                3-- 创建静态广播接收器需要在 AndroidManifest.xml 中注册，注册代码如下（快捷方式创建会自动生成） ：
                    <receiver
                        android:name=".BootCompleteReceiver"
                        android:enabled="true"
                        android:exported="true">
                    </receiver>
                4-- 在 AndroidManifest.xml 中添加涉及的权限（示例为开机自启权限）：
                    <intent-filter>
                        <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED" />
                    </intent-filter>  （添加到<receiver>标签中）
        5】注意点 ：onReceive()方法中需要添加过多的逻辑和耗时操作，因为广播接收器不允许开启线程，如果在此停留时间较长会报错
            广播接收器常扮演一个打开程序其他组件的角色
    2、发送自定义广播
        1】发送标准广播
            1)创建一个广播接收器来接收自定义广播 ：命名为 MyBroadcastReceiver
                修改对应的 AndroidManifest.xml 注册文件，这里设定的是发出的值
                <intent-filter>
                    <action android:name="com.example.broadcasttest.MY_BROADCAST" />
                </intent-filter>
            2）修改 activity_main.xml : 添加一个按钮，用来发送广播
                @Override
                public void onClick(View v) {
                    Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST");
                    sendBroadcast(intent);  //发送广播
                }
                代码解析 ：
                    构建一个Intent对象，将要发送的广播的中保存在Intent中，然后调用Context的sendBroadcast()方法发送广播
        2】发有序广播
            1）自定义广播接收器用于接收自定义广播 ：命名为 AnotherBroadcastReceiver
            2）修改对应的注册文件 ：
                <intent-filter>
                    <action android:name="com.example.broadcasttest.MY_BROADCAST" />
                </intent-filter>
            3）修改广播发送代码 ：sendOrderedBroadcast(intent, null);  //发送广播
                第一个参数 ：绑定发送值的Intent对象
                第二个参数 ：与权限有关的字符串，本实验用null
            4）设置广播接收器的优先级(在注册文件中设定)
                <intent-filter android:priority="100">
                    <action android:name="com.example.broadcasttest.MY_BROADCAST"/>
                </intent-filter>
                设置优先级为 100 ：android:priority="100"
            5）设置广播截断(在onReceive()方法中设置)
                abortBroadcast();  //这条广播被截断
    3、使用本地广播
        1】简介 ：本地广播只能在应用程序内部传递，并且广播接收器只能接收本程序发出的广播
        2】用法 ：主要是使用 LocalBroadcastManager
          两个全局变量 ：
                private LocalReceiver localReceiver;
                private LocalBroadcastManager localBroadcastManager;
            1）获取实例 ：localBroadcastManager = LocalBroadcastManager.getInstance(this);  //获取实例
            2）注册广播接收器 ；
                intentFilter = new IntentFilter();
                intentFilter.addAction("com.example.broadcast.LOCAL_BROADCAST");  //添加action
                localReceiver = new LocalReceiver();
                localBroadcastManager.registerReceiver(localReceiver, intentFilter);  //注册本地广播监听器
            3）发送广播 ：
                Intent intent = new Intent("com.example.broadcast.LOCAL_BROADCAST");
                localBroadcastManager.sendBroadcast(intent);  //发送本地广播
            4）取消注册 ：
                localBroadcastManager.unregisterReceiver(localReceiver);  //取消注册

        3】注意点 ：本地广播不能进行静态注册
        4】本地广播的优势 ：
            1）可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄漏。
            2）其他的程序无法将广播发送到我们程序的内部，因此不需要担心会有安全漏洞的隐患。
            3）发送本地广播比发送系统全局广播将会更加高效。

    4、广播实践--实现强制下线功能
        1】实现关闭应用程序所有活动（可参考app/java/com.example.activity/ActivityCollector.java）
            直接复制过来即可
        2】创建一个所有活动的父类（可参考app/java/com.example.activity/BaseActivity.java）
            直接复制过来即可
        3】创建登录界面活动（自动生成对应布局文件），活动命名为：LoginActivity
            1）首先为布局文件（activity_login.xml）添加控件（账号密码输入框和登录按钮）
            2）修改LoginActivity.java文件，代码部分参考文件
        4】在 BaseActivity.java 中添加广播接收器类，这是所有类的基类，所以所有界面接收到广播都会运行相关逻辑
            private class ForceOfflineRexeiver extends BroadcastReceiver {
            @Override
            public void onReceive(final Context context, Intent intent) {
                AlertDialog.Builder builder = new AlertDialog.Builder(context);  //创建对话框对象
                builder.setTitle("Warning");  //设置标题
                builder.setMessage("You are forced to be offline. Please try to login again.");  //设置显示内容
                builder.setCancelable(false);  //设置是否可被取消
                builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {  //设置确定按钮并添加点击事件
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        ActivityCollector.finishAll();  //销毁所有活动
                        Intent intent = new Intent(context, LoginActivity.class);
                        context.startActivity(intent);  //从新打开登陆界面
                    }
                });
                builder.show();  //显示对话框
            }
        }
        5】在 BaseActivity.java 中重写 onResume() 和 OnPause() 方法
            1）onResume() 中注册广播接收器
                @Override
                protected void onResume() {
                    super.onResume();
                    IntentFilter intentFilter = new IntentFilter();
                    intentFilter.addAction("com.example.broadcastbest.FORCE_OFFLINE");
                    receiver = new ForceOfflineRexeiver();
                    registerReceiver(receiver, intentFilter);  //注册广播接收器
                }
            2）在 OnPause() 中取消注册广播接收器
                @Override
                protected void onPause() {
                    super.onPause();
                    if (receiver != null) {
                        unregisterReceiver(receiver);  //取消广播接收器注册
                        receiver = null;
                    }
                }
        6】将主活动设置为 LoginActivity
            <activity android:name=".LoginActivity">
                <intent-filter>
                    <action android:name="android.intent.action.MAIN" />

                    <category android:name="android.intent.category.LAUNCHER" />
                </intent-filter>
    5、关于Git
        1】配置身份（用户名和邮箱）
            git config --global user.name "名称"
            git config --global user.email "邮箱"
        2】创建代码创库
            1）初始化（创建）
                git init
            2) 添加文件
                1-- 添加单个文件 ：git add 名称.后缀名
                2-- 添加一个文件夹下的所有文件 ：git add 文件夹名
                3-- 一次性添加所有文件 ：git add .
            3）添加完之后需要提交文件
                git commit -m "提示性信息"
        3】与远程仓库创建连接并同步（本地仓库和远程仓库要同名）
            1）与远程仓库创建连接
                git remote add origin git@github.com:LEGEND-LXM/ActivityTest.git
            2）本地同步到github仓库
                git push -u origin master

六、数据存储--数据持久化
    1、持久化技术简介
        1】内涵 ：数据持久化是将内存的瞬时数据保存到存储设备中，保证设备关闭后数仍然不会消失。持久化技术提供了数据在瞬时态和持久态之间进行转换
        2】两种数据保存方式 ：
            1）保存在内存中 ：数据是瞬时态，当应用程序关闭时会丢失
            2）保存在存储设备中 ：数据处于持久态，
        3】三种数据持久化方式
            1）文件存储
            2）SharedPreference存储
            3）数据库存储
          也可以保存在SD卡中
    2、文件存储
        1】简介 ：此方式不对存储的内容进行任何格式化处理，所有的数据原封不动的保存在文档中，常用于存储一些简单的文本数据或二进制数据。
        2】将数据存储在文件中
            1）Context类中的openFileOutput()方法 ：用于将数据存储在指定文件中，会返回一个FileOutputStream对象
                1-- 第一个参数 ：文件名称，文件创建是就是这个名称，这里的文件名不能包含路径，所有的文件默认存储在/data/data/<package name>/files/目录下
                2-- 第二个参数 ：文件的操作模式，主要有以下两种 ：
                    1- MODE_PRIVATE ：默认操作模式，表示如果文件存在则会覆盖原文件内容
                    2- MODE_APPEND ：如果文件存在就追加内容，不创建新文件
            2）案例 ：实现文件存储
              文件操作部分代码解读 ：
                //对FileOutputStream对象和BufferedWriter对象进行清空
                FileOutputStream out = null;
                BufferedWriter writer = null;
                try {
                        //对FileOutputStream对象和BufferedWriter对象进行初始化
                        out = openFileOutput("data", Context.MODE_PRIVATE);
                        writer = new BufferedWriter(new OutputStreamWriter(out));
                        //写入数据
                        writer.write(input);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }finally {
                        try {
                            //清空writer
                            if (writer != null) {
                                writer.close();
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                对FileOutputStream对象和BufferedWriter对象进行清空
        3】从文件中读取数据
            1）Context类中的openFileInput()方法 ：用于从文件中读取文件，只接受一个参数——文件名
                系统会自动到/data/data/<package name>/files/目录下去加载文件，返回一个FileInputStream对象
            2）案例 ：加载文件内容
                String text = loadFile();  //接收读取的数据
                  if (!TextUtils.isEmpty(text)) {  //判断非空
                      editText.setText(text);  //设置文本
                      editText.setSelection(text.length());  //移动光标
                      }

                public String loadFile() {
                //创建局部FileInputStream对象和BufferedReader对象并清零
                FileInputStream in = null;
                BufferedReader reader = null;
                //新建字符串对象
                StringBuilder content = new StringBuilder();
                try {
                    //打开文件
                    in = openFileInput("data");
                    //初始化BufferedReader对象
                    reader = new BufferedReader(new InputStreamReader(in));
                    String line = "";
                    //逐行读取并连接
                    while ((line = reader.readLine()) != null) {
                        content.append(line);
                    }
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    //关闭io流
                    try {
                        reader.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                //返回读取值
                return content.toString();
            }
            3）API ：
                setSelection(int a) : 将光标移动到第a个字符后面
                TextUtils.isEmpty(String text) ：对字符串进行非空判断（为null或“”时返回true）

    3、SharedPreferences 存储
        1】简介 ：使用键值对的方式存储数据，读取数据时通过键来读取数据
        2】使用SharedPreferences存储和读取数据
            1）首先要获取 SharedPreferences 对象，获取对象的三种方法：
                1--  Context类中的 getSharedPreferences()方法
                    参数1 ：用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences 文件存放在/data/data/<package name>/shared_prefs/中
                    参数2 ：指定操作模式，可选值只有 MODE_PRIVATE，表示只有当前应用程序能对此 SharedPreferences 文件进行读写
                2-- Activity类中的getPreferences()方法
                    参数 ：唯一参数，指定操作模式（使用此方法时会自动将当前活动的类名作为SharedPreferences的文件名）
                3-- PreferenceManager类中的getDefaultSharedPreferences()方法---静态方法
                    参数 ：唯一参数，Context参数，自动使用当前应用程序的包名作为前缀来命名SharedPreferences文件
            2）对 SharedPreferences 文件进行数据存储操作
                1-- 调用 SharedPreferences 对象的 edit ()方法来获取一个 SharedPreferences.Editor 对象
                2-- 向 SharedPreferences.Editor 对象中添加数据，比如添加一个布尔型数据就使用 putBoolean()
                   方法，添加一个字符串则使用 putString()方法，以此类推
                3-- 调用 apply ()方法将添加的数据提交，从而完成数据存储操作
                4-- 保存数据基本流程（示例）
                    //获取 SharedPreferences.Editor 对象
                    SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();
                    //保存数据
                    editor.putString("name", "tom");
                    editor.putInt("age", 19);
                    editor.putBoolean("married", false);
                    //提交保存
                    editor.apply();
            3）对 SharedPreferences 文件进行数据读取操作
                1-- 获取 SharedPreferences 对象，与数据存储相同
                2-- 使用 SharedPreferences 对象对应的get方法来获取数据，例如getBoolean()就是获取Boolean类型数据
                   此处的get方法与存储中的put方法一一对应
                    参数1 ：数据对应的键
                    参数2 ：默认值，当键不存在时的返回值
                3-- 示例 ：
                    //获取 SharedPreferences 对象
                    SharedPreferences preferences = getSharedPreferences("data", MODE_PRIVATE);
                    //读取数据（如果找不到键对应的值则会返回第二个参数）
                    String name = preferences.getString("name", "");
                    int age = preferences.getInt("age", -1);
                    Boolean married = preferences.getBoolean("married", false);
                    //打印日志
                    Log.d("MainActivity", "name:"+name);
                    Log.d("MainActivity", "age:"+age);
                    Log.d("MainActivity", "married:"+married);

         3】实现记住密码功能
            保存 ：勾选复选框后将数据保存
            设置 ：在活动布局加载时调用读取数据代码，然后设置为密码

    3、SQLite数据库存储
        1】简介 ：轻量级关系型数据库，占用资源少，通常只需要几百KB，支持标准SQL语法，遵循数据库的ACID事物；适用于保存大量复杂的关系型数据
        2】创建数据库 ：借助 SQLiteOpenHelper 帮助类对数据库进行创建和升级
            1）简介 ：SQLiteOpenHelper类是一个抽象类，需要被继承才能使用，需要重写的抽象方法onCreate()、onUpgrade(),创建和打开数据库的实例方法 ：
                1-- getReadableDatabase() : 创建或打开现有数据库（不存在则创建），返回一个可对数据库进行读写的对象，当数据库不可写入时，以只读的方式打开
                2-- getWritableDatabase() : 创建或打开现有数据库（不存在则创建），返回一个可对数据库进行读写的对象，出现异常
            2）构造方法 ：共有两个，使用参数较少的即可（4个）
                参数1 ：Context上下文对象
                参数2 ：数据库名
                参数3 ：允许我们在查询数据时返回一个自定义的Cursor（一般情况下使用null）
                参数4 ：当前数据库的版本号，用于对数据库进行升级
            3）数据库保存地址 ：/data/data/<package name>/database/
            4）onCreate方法通常去处理一些创建表的逻辑
            5）创建数据库示例演示 ：
                1-- 数据库创建语法 ：定义为字符串常量
                    //创建数据库语法id(主键)、作者、价格、页数、书名
                    //primary key ：主键
                    //autoincrement ：自增长
                    public static final String CREATE_BOOK = "create table Book (" +
                            "id integer primary key autoincrement, " +
                            "author text, " +
                            "price real, " +
                            "pages integer, " +
                            "name text)";
                2-- 执行数据库创建语法 ：execSQL()方法
                    public void onCreate(SQLiteDatabase db) {
                        db.execSQL(CREATE_BOOK);
                        Toast.makeText(mContext, "create succeed", Toast.LENGTH_SHORT).show();
                    }
                3-- 利用构造方法对 SQLiteOpenHelper 实例进行初始化
                    private DatabaseHelper dbHelper;
                    //SQLiteOpenHelper 实例进行初始化
                    dbHelper = new DatabaseHelper(this, "BookStore.db", null, 1);
                    此处 ：
                         数据库名称 ：BookStore.db
                         版本号 ：1
                4-- 创建数据库 ：
                    dbHelper.getWritableDatabase();
                    真正的创建语句在 SQLiteOpenHelper 子类的 onCreate方法中

                5-- 查看数据库的表 ：
                    使用adb shell来查看，adb是Android Studio自带的工具，存放在sdk的platform-tools目录下，配置环境变量 ：
                        windows ：右键计算机->属性->高级系统设置->环境变量->系统变量->Path
                                然后将platform-tools目录编辑进去
                    详细步骤查看《第一行代码 第2版》 P215
        3】升级数据库
            1）重写的 onUpgrade() 方法用于更新数据库，例如：添加表
            2）小知识点 ：当数据库已经存在时，将不会在进入onCreate() 方法,因此不能在创建完数据库后在onCreate() 方法中添加表
            3）更新数据库示例 ：添加一张表
                @Override
                public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                    //如果表 Book 和 表 Category 已存在则删除这两张表，然后调用onCreate()方法
                    db.execSQL("drop table if exists Book");
                    db.execSQL("drop table if exists Category");
                    onCreate(db);
                }
                注意 ：
                    想要运行 onUpgrade 方法需要在调用初始化语句：dbHelper = new DatabaseHelper(this, "BookStore.db", null, 1);时最后一个参数
                  版本号大于最后一次的版本号，这样会先调用 onUpgrade 方法删除相关数据表，然后调用onCreate 方法重新创建

        4】添加数据
            1）简介 ：创建数据库时会返回一个 SQLiteDatabase对象 用来对数据库进行数据的添加、更新、查询、删除
            2）方法 ：SQLiteDatabase对象的 insert() 方法用于向数据表添加数据
                参数1 ：数据表的名称
                参数2 ：用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL(一般使用null)
                参数3 ：ContentValues 对象，他提供了一系列的put方法重载，用于向ContentValues中添加数据，将表中的列名以及相应的待添加数据传入即可
            3）插入一条数据如下 ：
                //获取SQLiteDatabase对象
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                //创建ContentValues对象来保存数据
                ContentValues values = new ContentValues();
                //开始组装第一条数据
                values.put("name", "The Da Vinci Code");
                values.put("author", "Dan Brown");
                values.put("pages", 454);
                values.put("price", 16.96);
                //插入第一条数据
                db.insert("Book", null, values);
              注意 ：ContentValues 对象有一个clear() 方法，用来清空数据，在添加多条数据时可使用
        5】更新数据
            1）方法 ：SQLiteDatabase对象的 updata() 方法用于向数据表更新数据
                参数1 ：数据表名
                参数2 ：ContentValues对象，将要更新的数据装进去
                参数3 ：约束某一行或某几行中的数据，不指定默认更新所有行
                参数4 ：约束某一行或某几行中的数据，不指定默认更新所有行
            2）示例 ：
                //获取SQLiteDatabase对象
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                //创建ContentValues对象来保存需要更新的数据
                ContentValues values = new ContentValues();
                values.put("price", 10.00);
                db.update("Book", values, "name=?", new String[] {"The Da Vinci Code"});
              参数3 ：相当于SQL语句中的where部分，"name=?" 中的 "?" 为一个占位符，由参数4补齐
        6】删除数据
            1）方法 ：SQLiteDatabase对象的 delete() 方法用于删除数据表中的数据
                参数1 ：数据表名
                参数2 ：用来约束删除某一行或某几行的数据，不指定默认为删除所有行
                参数3 ：用来约束删除某一行或某几行的数据，不指定默认为删除所有行
            2）示例 ：
                //获取SQLiteDatabase对象
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                db.delete("Book", "id=?", new String[] {"2"});
        7】查询数据
            1）方法 ：SQLiteDatabase对象的 query() 方法用于查询数据表中的数据
              此方法很复杂，最简单的一种用法如下 ：
                参数1 ：数据表名
                参数2 ：指定查询那几列
                参数3 和 参数4 ：用于约束查询哪几行，不指定则默认查询所有行
                参数5 ：指定是否需要进行group by（分组）操作
                参数6 ：对group by 之后的结果进行进一步约束
                参数7 ：指定查询结果的排列方式
              此方法会返回一个Cursor对象，数据从这个对象中提取出来
            2）示例 ：
                //获取SQLiteDatabase对象
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                // 查询Book表中的所有数据（null表示采用默认）
                Cursor cursor = db.query("Book", null, null, null, null, null, null);
                if(cursor.moveToFirst()) {
                    do {
                        //遍历Cursor对象，取出数据并打印
                        String name = cursor.getString(cursor.getColumnIndex("name"));
                        String author = cursor.getString(cursor.getColumnIndex("author"));
                        int pages = cursor.getInt(cursor.getColumnIndex("pages"));
                        double price = cursor.getDouble(cursor.getColumnIndex("price"));
                        String str = "name ：" + name + "\n" + "name ：" + name + "\n" + "author ：" + author + "\n" + "pages ：" + pages + "\n" + "price ：" + price ;
                        Log.d("MainActivity", str);

                    }while(cursor.moveToNext());
                }
                cursor.close();

                    1-- cursor.moveToFirst() ：将指针移到第一行
                    2-- cursor.getColumnIndex() ：获取某一列对应位置的索引
                    3-- cursor.getDouble() : 获取对应索引的浮点型数据（其他类型类似）
                    4-- 注意 ：最好需要调用"cursor.close();"关闭对象
        8】使用SQL原生语言操作数据库
            Android studio 支持使用原生SQL语言操作数据库

            添加数据、更新数据、删除数据 使用 db.execSQL("原生SQL语言", 占位符的解释) 的方式操作
            查询数据使用 db.rawQuery("原生SQL语言", 占位符的解释) 的方式操作
    4、使用 LitePal 操作数据库
        1】简介 ：LitePal 是一个开源的Android数据库框架，采用了对象关系映射（ORM）的模式，对数据库功能进行了封装，不用使用SQL语句就可以完成各种操作。
        2】配置 LitePal
            1）添加 LitePal 开源库 ：开源项目会将版本号提交到jcenter上，在build.gradle中声明即可
            2）添加声明 ：implementation 'org.litepal.guolindev:core:3.1.1' (可去qithub相关项目站查看添加语句)
            3）配置 litepal.xml文件 ：
                1-- 在 模块（或app）/src/main 目录下创建一个名为 assets的Directory，在这个目录下新建一个 litepal.xml文件
                2-- 具体类容可去qithub相关项目站查看添加语句（也可参考此工程中的LitePal moudle）
                3-- 相关解释说明
                    <dbname value="demo" /> ：指定数据库名（配置时需更改）
                    <version value="1" /> ：指定数据库版本
                    <list> ：用来指定所有的映射模型
            4）修改 AndroidManifest.xml 文件 ：
                <manifest>
                    <application
                        android:name="org.litepal.LitePalApplication" （添加此句）
                        ...
                    >
                        ...
                    </application>
                </manifest>
            5）对象关系映射
                面向对象的语言与面向关系的数据库之间的映射，用面向对象的思维来操作数据库，不需要使用SQL语言

        3】创建和升级数据库
            1）创建数据库并添加一张表 ：
                1-- 创建一个java类，名称为表名称
                2-- 在这个类中创建对应的字段，并创建对应的get、set方法（参考 Book.java）
                3-- 将Book类添加到映射模型列表中（修改litepal.xml中的语句）
                    <list>
                        <mapping class="com.example.litepal.Book" />
                    </list>
                4-- 现在任意一次数据库操作就可以自动创建出BookStore数据库
                5-- 此处可使用最简单的数据库操作语句来创建数据库 ：Connector.getDatabase();
            2）升级数据库
                直接更改数据表中的内容然后版本号 +1 即可
        4】使用 LitePal 添加数据
            1） 创建出 数据表类的实例
                Book book = new Book();
            2） 设置需要存储的数据
                book.setName("The Da Vinci Code");
                book.setAuthor("Dan Brown");
                book.setPages(454);
                book.setPrice(16.95);
                book.setPress("Unknown");
            3） 最后调用save()方法
                book.save();
            4） 注意 ：LitePal 进行表管理的时候不需要继承结构，但是在进行CRUD操作时需要继承 LitePalSupport
        5】使用 LitePal 更新数据
            1）较为简单的一种方式 ：对已存储对象重新设值，然后重新调用sava()方法保存
                1-- 判断是否为已存储对象方法 ：model.isSaved() ,返回true表示已存储，返回false表示未存储
                2-- 返回true的情况 ：
                    1- 已经调用过 model.save() 方法
                    2- model对象是通过LitePal提供的查API查询出来的
            2）此时先利用 第一种 返回 true 的方法来试验，代码如下 ：
                Book book = new Book();
                book.setName("The Da Vinci Code");
                book.setAuthor("Dan Brown");
                book.setPages(454);
                book.setPrice(16.95);
                book.setPress("Unknown");
                book.save();
                book.setPrice(10.21);
                book.save();
            2）利用 第二种 返回 true 的方法来试验
                1-- 新建一个Book实例
                    Book book = new Book();
                2-- 更改对应字段数据
                    book.setPrice(14.26);
                    book.setPress("Anchor");
                3-- 调用updata相关方法来进行更新操作
                    1- update() : 参数为对应行的 id
                        book.update(1);
                    2- updateAll() ：参数为限定条件
                        book.updateAll("name = ? and author=?", "The Da Vinci Code", "Dan Brown");
                    3- 注意 ：用这种方法无法更新数据为默认值（例如：int类型数据默认值为0，"book.setPages(0);"是不被允许的，因为新建对象的其他值为默认值）
                        更新为默认值的方法 ：
                            Book book = new Book();
                            bookb.setToDefault("pages");  //更新为默认值的方法
                            book.updateAll();
        6】使用 LitePal 删除数据
            1）（第一种方法）调用已存储对象的 delete() 方法
            2）调用LitePal的相关delete方法 ：
                1-- LitePal.deleteAll() ：删除数据表中的匹配行数据
                    参数1 ：数据表的类名（例如：Book.class）
                    后续的参数 ：约束条件
                    例 ：LitePal.deleteAll(Book.class, "id = ?", "3");
                2-- LitePal.delete() ：删除数据表中的某一行数据
                    参数1 ：数据表的类名（例如：Book.class）
                    参数2 ：数据行的 id
                    例 ：LitePal.delete(Book.class, 4);
                3-- LitePal.deleteDatabase() ：删除数据库
                    参数 ：数据库名称
        7】使用 LitePal 查询数据
            1）查询数据表中的所有数据 ：
                语法 ：List<数据表类名(不带.java)> 列表名称 = LitePal.findAll(数据表类名(带.java));
                例 ：List<Book> books = LitePal.findAll(Book.class);
                实例 ：查询数据表并遍历打印
                    List<Book> books = LitePal.findAll(Book.class);
                    for (Book book : books) {  //遍历列表
                        Log.d("MainActivity", "id : " + book.getId());
                        Log.d("MainActivity", "name : " + book.getName());
                        Log.d("MainActivity", "author : " + book.getAuthor());
                        Log.d("MainActivity", "pages : " + book.getPages());
                        Log.d("MainActivity", "price : " + book.getPrice());
                        Log.d("MainActivity", "press : " + book.getPress());
                    }
            2）查询某一条数据（指定id）
                语法 ：数据表类名(不带.java)> 对象名称 = LitePal.find(数据表类名(带.java), id);
                例 ：List<Book> books = LitePal.findAll(Book.class);
                实例 ：查询id=1的数据
                    Book book = LitePal.find(Book.class, 1);
                    Log.d("MainActivity", "id : " + book.getId());
                    Log.d("MainActivity", "name : " + book.getName());
                    Log.d("MainActivity", "author : " + book.getAuthor());
                    Log.d("MainActivity", "pages : " + book.getPages());
                    Log.d("MainActivity", "price : " + book.getPrice());
                    Log.d("MainActivity", "press : " + book.getPress());
            3）LitePal.findFirst() ：查询第一行数据
                语法 ：数据表类名(不带.java)> 对象名称 = LitePal.findFirst(数据表类名(带.java));
                例 ：Book book = LitePal.findFirst(Book.java);
            4）LitePal.findLast() ：最后一行数据
                语法 ：数据表类名(不带.java)> 对象名称 = LitePal.findLast(数据表类名(带.java));
                例 ：Book book = LitePal.findLast(Book.java);

            5）LitePal.select() ：指定查询哪几列的数据
                语法 ：List<数据表类名(不带.java)> 列表名称 = LitePal.select(指定查询的列名称).find(数据表类名(带.java));
                例 ：List<Book> books =  LitePal.select("name", "pages").find(Book.java);  (只查询 name 和 pages两列)
            6）LitePal.where() : 添加约束条件查询
                语法 ：List<数据表类名(不带.java)> 列表名称 = LitePal.where(约束条件).find(数据表类名(带.java));
                例 ：List<Book> books =  LitePal.where("id<?", "3").find(Book.java);  (查询id<3的数据行)
            7）LitePal.order() ：用于指定结果的排序方式（升降序）
                语法 ：List<数据表类名(不带.java)> 列表名称 = LitePal.order(约束条件).find(数据表类名(带.java));
                例 ：List<Book> books =  LitePal.order(price desc").find(Book.java);  (查询结果按price列降序排列)
              desc ：表示降序； asc或者不写 ：表示升序
            8）LitePal.limit() ：指定查询结果的数量（取查询结果的前num条）
                语法 ：List<数据表类名(不带.java)> 列表名称 = LitePal.limit(int num).find(数据表类名(带.java));
                例 ：List<Book> books =  LitePal.limit(3).find(Book.java);  (查询结果取前三行)
            9）LitePal.offset() ：指定查询结果的偏移量（查询结果向后偏移）
                语法 ：List<数据表类名(不带.java)> 列表名称 = LitePal.offset(int(偏移量)).find(数据表类名(带.java));
                例 ：List<Book> books =  LitePal.offset(1).find(Book.java);  (查询结果整体向后偏移1位，2、3、4变为3、4、5)
          5）-----9）这5种方法可以混合使用完成复杂条件查询
        8】LitePal 也支持使用SQL原生语言查询
            语法 ：Cursor 对象名称 = LitePal.findBySQL(SQL原生语言)；
            参数1 ：位SQL语言
            后续参数 ：占位符内容
七、跨程序共享数据--内容提供器
    1、内容提供器简介
        1）内容提供器用于在不同应用程序间实现数据共享，它允许一个程序访问另一个程序的数据，同时还能保证被访问数据的安全性。
        2）内容提供器可以选择只对部分数据进行共享，保证隐私不会泄露

    2、运行时权限
        1】Android 权限机制详解
            1）作用 ：
                1-- 设置相关权限后可以再安装时显示给用户看，让软件无法滥用权限
                2-- 可以在应用管理界面随时查看软件涉及的权限
            2）弊端 ：
                当对应用程序产生依赖性时，就有可能被软件绑架，给予软件一些与隐私相关的权限
        2】运行时权限
            1）简介 ：6.0系统中加入了运行时权限功能，用户不需要在安装软件时一次性授予所有申请的权限，而是在使用的过程中对相关权限的申请进行授予。
                    这保证了用户拒绝不必要权限后还能继续使用其他功能
            2）权限分类 ：为了解决一直授权带来的麻烦
                1-- 普通权限 ：不会直接威胁到用户安全和隐私的权限，这些系统会自动的帮我们去授权，不需要用户再去手动授权
                        普通权限的使用只需要在 AndroidManifest.xml 中添加即可
                2-- 危险权限 ：可能会触及到用户隐私或者对设备安全性造成影响的权限（例如：获取通讯录、短信、地理位置），这部分的权限需要用户手动授权
                        所有的危险权限 ：
                             权限组名    ：                  权限名
                            （日历）
                            CALENDAR    ：    READ_CALENDAR   、   WRITE_CALENDAR
                            （相机）
                            CAMERA      ：    CAMERA
                            （联系人）
                            CONTACTS    ：    READ_CONTACTS   、  WRITE_CONTACTS   、  GET_CONTACTS
                            （位置）
                            LOCATION    ：    ACCESS_FIND_LOCATION   、   ACCESS_COARSE_LOCATION
                            （麦克风）
                            MICROPHONE  ：    RECORD
                            （电话）
                            PHONE       ：    READ_PHONE_STATE   、   CALL_PHONE   、  READ_CALL_LOG   、   WRITE_CALL_LOG   、
                                              ADD_VOICEMAIL   、   USE_SIP   、   PROCESS_OUTGOING_CALLS
                            （传感器）
                            SENSORS     :     BOOY_SENSORS
                            （信息）
                            SMS         ：    SEND_SMS   、   RECEIVE_SMS    、   READ_SME   、    RECEIVE_WAP_PUSH   、
                                              RECEIVE_MMS
                            （储物）
                            STORAGE     ：    READ_EXTERNAL_STORAGE   、  WRITE_EXTERNAL_STORAGE
                    注意 ：我们进行权限处理时是用的权限名，授权后该权限对应的权限组中的所有权限都会被授权

    3、在程序运行时申请权限(以拨打电话为例)
        1】6.0以下版本实现拨打电话（这种方法只适用于Android6.0以下）
            1-- 构建一个Intent，将他的action指定为Tntent.ACTION_CALL(系统内置的打电话动作)，在data部分指定协议为tel，号码：10086
                try {
                    Intent intent = new Intent(Intent.ACTION_CALL);
                    intent.setData(Uri.parse("tel:10086"));
                    startActivity(intent);
                } catch (SecurityException e) {
                    e.printStackTrace();
                }
                代码放在异常捕获中，防止出现问题
            2-- 在 AndroidManifest.xml 文件中添加权限声明
                <uses-permission android:name="android.permission.CALL_PHONE" />

        2】运行时权限的使用
            1）核心 ：在应用程序运行时用户授权某些危险操作
            2）权限判断及授权部分代码
                /** 判断用户是否已经授权该权限
                 * 方法：ContextCompat.checkSelfPermission
                 * 参数1 ：context  ； 参数2 ：相关权限名
                 * 将返回值与对应值进行判断，相等则为已授权
                 * 授予后直接执行拨打电话的逻辑
                **/
                if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE)
                != PackageManager.PERMISSION_GRANTED) {
                    /**
                     * 进行权限授予
                     * 方法 ：ActivityCompat.requestPermissions
                     * 参数1 ：Activity实例  ； 参数2 ：申请的权限名，放在数组中   ； 参数3 ：请求码，是唯一值即可（这里用1）
                     * 此方法在调用后会弹出一个权限申请对话框
                     * 无论用户同意或拒绝都会调用onRequestPermissionsResult()方法
                     **/
                    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.CALL_PHONE}, 1);
                } else {
                    call();
                }
            3）拨打电话逻辑代码
                /**
                 * 拨打电话逻辑
                 * */
                private void call() {
                    try {
                        Intent intent = new Intent(Intent.ACTION_CALL);
                        //此处的电话可以捕获编辑框输入的号码
                        intent.setData(Uri.parse("tel:10086"));
                        startActivity(intent);
                    } catch (SecurityException e) {
                        e.printStackTrace();
                    }
                }
            4）权限授予返回处理部分代码
                @Override
                public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
                    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                    switch(requestCode) {
                        case 1:  //此处的 1 为请求码，在权限申请时传入
                            /**
                             * 判断权限申请返回结果
                             * 返回的值为 grantResults
                             * 下列代码意为 ：同意则调用拨打电话代码，拒绝则显示未授权文本
                             **/
                            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                                call();
                            } else {
                                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();
                            }
                            break;
                        default:
                    }
                }
            取消权限授予方法 ：setting -> Apps -> 对应应用程序 -> Permission
            5）在这种方法下也需要 在 AndroidManifest.xml 文件中添加权限声明

    4、访问其他程序中的数据
        1】内容提供器的两种用法
            1）使用现有的内容提供器来读取和操作相应程序中的数据
            2）创建自己的内容提供器给我们的数据提供外部访问接口
                当应用程序通过内容提供器对其数据听了外部访问接口，那么任何其他应用程序就都可以对这部分数据进行访问
        2】ContentResolver 的基本用法
            1）简介 ：借助 ContentResolver 类才能访问内容提供器中共享的数据
            2）对实例对象的操作 ：
                1-- 获取实例方法 ：Context中的 getContentResolver() 方法
              以下四种操作为获取的实例的操作
                2-- 添加数据 ：insert()
                3-- 更新数据 ：update()
                4-- 删除数据 ：delete()
                5-- 查询数据 ：query()
              这四种方法不接收表名参数，使用一个Uri唯一参数，被称之为内容URI
            3）内容URI
                1-- 简介 ：内容URI给内容提供器中的数据建立了唯一标识符
                2-- 组成部分 ：authority 和 path
                3-- authority : 用于对不同程序作区分，一般采用程序包名进行命名
                4-- path ：用于对同一应用程序不同的表作区分的，通常将path放在authority后面
                5-- 内容URI的标准写法 ：
                    content://com.example.app.provider/table1
                    content://com.example.app.provider/table2
                              ----------------------- -------
                              authority（c开始）       path（/开始）
                6-- 将URI字符串解析为Uri对象 ：Uri.parse()方法
                    Uri uri = Uri.parse("content://com.example.app.provider/table1");
            4）查询数据
                1-- 语法 ：
                    Cursor cursor = getContentResolver().query(
                        uri,            //指定需要查询的数据表
                        projection,     //指定查询的列名
                        selection,      //约束条件
                        selectionArgs,  //约束条件中的占位符补充
                        sortOrder       //查询结果的排序方式
                    );
                2-- 查询之后从 Cursor 对象中取出数据即可
            5）添加数据
                1-- 新建一个ContentValues对象，将数据保存进去,例：
                    ContentValues values = new  ContentValues();
                    values.put("column1", "text");  //添加第一列的内容
                    values.put("column2", 1);  //添加第二列内容
                2-- 调用 getContentResolver().insert()方法保存即可
                    参数1 ：Uri对象  ； 参数2 ：ContentValues对象
                    保存 ：getContentResolver().insert(uri, values);
            6）更新数据
                1--  新建一个ContentValues对象，将需要更新的数据保存进去（只需要保存需要更新的部分）
                    ContentValues values = new  ContentValues();
                    values.put("column1", "");  //保存需要更新的内容
                2-- 调用 getContentResolver().update() 方法更新
                    参数1 ：Uri对象
                    参数2 ：ContentValues对象
                    参数3 ：约束条件
                    参数4 ：约束条件中的占位符补充（用字符串数组来表示）
                    更新 ：getContentResolver().insert(uri, values, "column1 = ? and column2 = ?",
                                                        new String[] {"text", "1"});

            7）删除数据
                直接调用getContentResolver().delete()方法即可
                参数1 ：Uri对象
                参数2 ：约束条件
                参数3 ：约束条件中的占位符补充（用字符串数组来表示）
                删除 ：getContentResolver().delete(uri, "column2 = ?", new String[] {"1"})

        3】读取系统联系人列表（Contacts module）
            1）ListView控件初始化和运行时权限申请部分
                // 获取ListView控件实例
                ListView contactsView = findViewById(R.id.contacts_view);
                // 初始化适配器
                adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, contactsList);
                // 设置适配器
                contactsView.setAdapter(adapter);
                /**
                 * 运行时权限获取
                 * 此处授权权限为联系人读取权限
                 * */
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) !=
                        PackageManager.PERMISSION_GRANTED) {
                    ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.READ_CONTACTS}, 1);
                } else {
                    readContacts();
                }
            2）联系人获取部分
                private void readContacts() {  // 读取联系人列表
                    Cursor cursor = null;
                    try {
                        // 进行联系人查询， "ContactsContract.CommonDataKinds.Phone.CONTENT_URI" 系统包装好的Uri对象
                        cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);
                        if (cursor != null) {  //判断查询结果飞空
                            while(cursor.moveToNext()) {  // 非空情况下一项一项读取
                                // 获取联系人名称，"ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME" 联系人姓名这一列对应的常亮
                                String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
                                // 获取联系人电话，"ContactsContract.CommonDataKinds.Phone.NUMBER" 联系人电话这一列对应的常亮
                                String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
                                // 添加打ListView控件中
                                contactsList.add(displayName + "\n" + number);
                            }
                            // 刷新ListVIew
                            adapter.notifyDataSetChanged();
                        }
                        } catch (Exception e) {
                            e.printStackTrace();
                    } finally {
                        if (cursor != null) {
                            // 最后需要关闭cursor
                            cursor.close();
                        }
                    }
                }
            3）权限授予结果回调部分
                @Override
                public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
                    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                    /**
                     * 权限授予的结果回调判断
                     * */
                    switch (requestCode) {
                        case 1 :
                            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                                readContacts();
                            } else {
                                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();
                            }
                            break;
                        default:
                    }
                }
            4）在 AndroidManifest.xml 文件中添加权限声明部分
                <uses-permission android:name="android.permission.READ_CONTACTS"/>

    5、创建内容提供器
        1】简介 ：使用内容提供器共享数据需要新建一个类继承 ContentProvider 来创建自己的内容提供器，需要重写6个抽象方法
        2】需要重写的抽象方法 ：
            1）onCreate()
                进行内容提供器的初始化，在这里完成数据库的创建和升级，返回true表示内容提供器初始化成功。
                注意 ：只有当 ContentResolver 尝试访问我们的程序时，内容提供器才会初始化
                例 ：
                    @Override
                    public boolean onCreate() {
                        return false;
                    }
            2）query()
                用于在内容提供器中查询数据，使用uri参数确定查询的表，用projection参数来确定查询的列，selection和selectionArgs参数为约束条件
                sortOrder参数用于对结果进行排序，查询结果存放在Cursor对象中返回
                例 ：
                    @Nullable  // 表示参数可为空
                    @Override
                    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
                        return null;
                    }
            3）insert()
                向内容提供器中添加一条数据。使用uri参数确定添加数据的表，待添加数据保存在values参数中。
                添加完成后，返回一个用于标识这条新纪录的URI
                例 ：
                    @Nullable
                    @Override
                    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
                        return null;
                    }
            4）update()
                更新内容提供器中的数据，使用uri参数确定更新内容的表，待更新数据保存在values参数中，selection和selectionArgs参数为约束条件，
                受影响的行将作为返回值返回。
                例 ：
                    @Override
                    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
                        return 0;
                    }
            5）delete()
                从内容提供器中删除数据。使用uri参数确定需要删除数据的表，selection 和 selectionArgs 为约束条件，被删除
                的行数被作为返回值返回
                例 ：
                     @Override
                    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
                        return 0;
                    }
            6）getType()
                根据传入的内容URI来返回对应的MIME类型
                例 ：
                    @Nullable
                    @Override
                    public String getType(@NonNull Uri uri) {
                        return null;
                    }

        3】解析Uri语句
            1）构建内容提供器的实质 ：对 uri 语句进行解析，然后根据解析出来的数据对对应的数据库的数据表进行IUDQ操作
            2）编写内容URI语句 ：内容URI的两种标准写法
                 1-- content://com.example.app.provider/table1/1 （访问表中id=1的数据）
                 2-- content://com.example.app.provider/table1 （访问表中所以数据）
                我们可以使用通配符来分别匹配这两种格式的URI
                    * ：匹配任意长度的任意字符
                    例 ：content://com.example.app.provider/*  ：匹配任意表的内容URI语句
                    # ：匹配任意长度的数字
                    例 ：content://com.example.app.provider/table1/#  ：匹配table1表中任意一行的内容URI语句
        4】使用方法 ：
            1）新建一个类继承 ContentProvider 来创建自己的内容提供器
            2）在这个新建类中重写6个方法（参考2】）
            3）解析URI语句（URI语句的格式参考3】）
                解析方法 ：
                    借助 UriMatcher 这个类可以实现匹配内容URI的功能。UriMatcher 听了addURI()方法，将authority、path和一个自定义代码传进去，
                  这样在调用 UriMatcher 的 match()方法时就可以将Uri对象传入，返回值就是能够匹配这个Uri对象的自定义代码，利用这个代码，我们就
                  可以判断出期望访问的数据表了。
                    示例 ：(创建一个内容提供器)
                        public class MyProvider extends ContentProvider {
                        /**
                         * 新增4个微型常量
                         * TABLE1_DIR ：访问table1表的全部数据
                         * TABLE1_ITEM ：访问table1表中的单条数据
                         * TABLE2_DIR ：访问table2表的全部数据
                         * TABLE2_ITEM ：访问table2表中的单条数据
                         * */
                        public static final int TABLE1_DIR = 0;
                        public static final int TABLE1_ITEM = 1;
                        public static final int TABLE2_DIR = 2;
                        public static final int TABLE2_ITEM = 3;

                        public static UriMatcher uriMatcher;  // 创建 UriMatcher 实例

                        static {
                            /**
                             * 对 UriMatcher 实例进行初始化；
                             * 调用addURI()将期望匹配的内容URI格式传入进去；
                             * 传入的参数可以使用通配符；
                             * 当调用query()方法时会通过 UriMatcher 对象的match()方法对传入的URI，
                             * 与addURI()事先传入的进行匹配，如果匹配成功会返回自定义代码，从而进行对应操作；
                             * delete()、insert()、update()的使用与query()相似
                             * */
                            uriMatcher = new UriMatcher(uriMatcher.NO_MATCH);
                            uriMatcher.addURI("com.example.app.provide", "table1", TABLE1_DIR);
                            uriMatcher.addURI("com.example.app.provide", "table1/#", TABLE1_ITEM);
                            uriMatcher.addURI("com.example.app.provide", "table2", TABLE2_DIR);
                            uriMatcher.addURI("com.example.app.provide", "table2/#", TABLE2_ITEM);
                        }

                        @Override
                        public boolean onCreate() {
                            return false;
                        }

                        @Nullable
                        @Override
                        public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
                            switch (uriMatcher.match(uri)) {
                                case TABLE1_DIR :
                                    // 查询table1表中的所有数据
                                    break;
                                case TABLE1_ITEM :
                                    // 查询table1表中的单条数据
                                    break;
                                case TABLE2_DIR :
                                    // 查询table2表中的所有数据
                                    break;
                                case TABLE2_ITEM :
                                    // 查询table2表中的单条数据
                                    break;
                                default:
                                    break;
                            }
                            return null;
                        }

                        @Nullable
                        @Override
                        public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
                            return null;
                        }

                        @Override
                        public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
                            return 0;
                        }

                        @Override
                        public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
                            return 0;
                        }
                        /**
                         * 关于getType
                         * 作用 ：用于获取Uri对象所对应的MIME类型
                         * 内容URI对应的MIME组成 ：
                         *      必须以vnd开头
                         *      如果内容URI以路径结尾，则后接android. cursor.dir/,如果内容URI以id结尾,则后接android. cursor.item/
                         *      最后接上 vnd.<authority>.<path>
                         *   例 ：content://com.example.app.provider/table1 的MIME类型 vnd.android. cursor.dir/vnd.com.example.app.provider.table1
                         *   例 ：content://com.example.app.provider/table1/1 的MIME类型 vnd.android. cursor.item/vnd.com.example.app.provider.table1
                         * */
                        @Nullable
                        @Override
                        public String getType(@NonNull Uri uri) {
                            switch (uriMatcher.match(uri)) {
                                case TABLE1_DIR :
                                    return "vnd.android. cursor.dir/vnd.com.example.app.provider.table1";
                                case TABLE1_ITEM :
                                    return "vnd.android. cursor.item/vnd.com.example.app.provider.table1";
                                case TABLE2_DIR :
                                    return "vnd.android. cursor.dir/vnd.com.example.app.provider.table2";
                                case TABLE2_ITEM :
                                    return "vnd.android. cursor.item/vnd.com.example.app.provider.table2";
                                default:
                                    break;
                            }
                        }
                    }
                  注意 ：这里必须要匹配到才能进行相关操作，所以只要不将隐私数据表添加进去就不会泄露隐私
    6、实现跨程序数据共享
        1】在 database module的基础上，通过内容提供器给它加入外部访问接口
        2】快速新建内容提供器 ：
            1) New -> Other -> Content -> Provider 可以打开内容提供器新建选项卡
                1-- authority : 指定应用程序的数据库命名（Uri语句中的authority）
                2-- Exported ：此复选框表示是否允许外部程序访问
                3-- Enabled ：此复选框表示是否启用内容提供器
        3】代码部分参考 database/java/com.example.database/MyContentProvider.java
        4】内容提供器需要在 AndroidManifest.xml 文件中注册（采用快捷生成的会自动注册）
            注册代码示例 ：
                <provider
                    android:name=".MyContentProvider"  // 指定 内容提供器的类名
                    android:authorities="com.example.database.provider"  // 指定了authorities
                    android:enabled="true"  // 启用内容提供器
                    android:exported="true"></provider>  // 允许其他出访问

八、运用手机多媒体
    1、在手机上运行程序
        1】准备 ：
            1-- 打开开发者模式
            2-- 设置 -> 开发者选项 -> 允许USB调试
            3-- 运行项目前选择设备为连接的设备
    2、使用通知  // 注意 ：以下代码仅对低版本Android有效 7.0 以下（6.0可以正常运行）
        1】简介 ：后台程序向用户发送的提示性信息，显示在手机顶部的状态栏中
        2】基本用法（4.0~7.0版本可用）
            1）通知很灵活，既可以在活动里创建，又可以在广播接收器中创建也可以在服务里创建（创建的步骤是相似的）
            2）首先需要一个 NotificationManager 来对通知进行管理，，调用 Context 的 getSystemService() 来获取
                getSystemService() 接收一个字符串参数用于确定获取系统的哪个服务，这里传入 Context.NOTIFICATION
                例 ：
                    NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            3）使用 Builder 构造器来创建 Notification 对象，使用support-v4 库中提供的 NotificationCompat 类来创建可以保证我们程序在
                多个Android版本的兼容性
                例 ：Notification notification = new NotificationCompat.Builder(context).build();
                1-- 上述方法只是创建了一个空的 Notification 我们可以在最终的build()方法前添加多个设置方法来创建一个丰富的 Notification
                    例 ：Notification notification = new NotificationCompat.Builder(context)
                                                    .setContentTitle("This is content title")
                                                    .setContentText("This is content text")
                                                    .setWhen(System.currentTimeMillis())
                                                    .setSmallIcon(R.drawable.small_icon)
                                                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon))
                                                    .build();
                    解释 ：
                        1- setContentTitle("This is content title") ：指定通知的标题内容
                        2- setContentText("This is content text") ：指定通知的正文内容
                        3- setWhen(System.currentTimeMillis()) ：指定通知被创建的时间，以毫秒为单位，当下拉状态栏时，这里指定的时间会显示在相应的通知里
                        4- setSmallIcon(R.drawable.small_icon) ：设置通知的小图标，只能使用alpha图层的图片，小图标会显示在通知栏上
                        5- setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)) ：设置通知的大图标，下拉状态栏时就可以看见

            4）完成上述设置后，调用 NotificationManager 的 notify() 方法就可以显示通知了
                1-- 参数1 ：通知的ID，每一个通知的id都不相同
                    参数2 ：Notification对象
        3】基本用法（兼容低版本）
          创建两个全局属性 ：
            // NotificationManager对象声明
            private NotificationManager manager;
            // 通知渠道id
            private String CHANNEL_ID = "my_channel_01";
            1）创建通知渠道(封装到函数中)
                1-- 构建一个在软件包内具有唯一 ID 的通知渠道对象。
                2-- 为该通知渠道对象配置所需的任何初始设置（例如提示音以及对用户可见的可选说明）。
                3-- 将通知渠道对象提交到通知管理器。
              注意 ：如果试图使用初始值创建的通知渠道已存在，不会执行任何操作，因此启动应用时可以放心地执行以上步骤序列
                4-- 示例代码 ：// 可反复执行，有版本判断机制，已创建的渠道不会再次创建
                    /**
                     * importance ：此参数确定出现任何属于此渠道的通知时如何打断用户
                     * Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
                     *      Build.VERSION.SDK_INT ：获取当前android版本号
                     *      此句的作用是获取版本号并判断，这样在低版本时就不需要创建通知渠道
                     * */
                    private void createNotificationChannel () {

                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                                CharSequence name = getString(R.string.channel_name);
                                String description = getString(R.string.channel_description);
                                int importance = NotificationManager.IMPORTANCE_DEFAULT;
                                NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
                                channel.setDescription(description);
                                // Register the channel with the system; you can't change the importance
                                // or other notification behaviors after this
                                manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
                                manager.createNotificationChannel(channel);
                            }
                        }
            2）创建通知
                // 调用创建渠道函数
                createNotificationChannel();
                /**
                 * 创建通知内容
                 * setContentTitle(getString(R.string.title)) ：设置通知的标题
                 * setContentText("This is Text") ：设置通知的正文
                 * setSmallIcon(R.mipmap.ic_launcher) ：设置通知小图标
                 * setPriority(NotificationCompat.PRIORITY_DEFAULT) ：设置通知优先级
                 * setStyle() ：设置通知的样式模板
                 * */
                NotificationCompat.Builder builder = new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                        .setSmallIcon(R.mipmap.ic_launcher)
                        .setContentTitle(getString(R.string.title))
                        .setContentText(getString(R.string.text))
                        .setPriority(NotificationCompat.PRIORITY_DEFAULT);
                manager.notify(1, builder.build());
        4】创建通知的点按操作
            1）简介 ：通知的点按操作用于点击消息打开对应的应用以及获得
            2）使用方法 ：
                1-- 创建 Intent 对象，初始化并关联需要打开的活动
                    Intent intent = new Intent(this, AlertDetails.class);
                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);

                    setFlags() ：帮助保留用户在通过通知打开应用后的预期导航体验，是否要使用这一方法取决于您要启动的 Activity 类型，类型包括 ：
                        1- 专用于响应通知的 Activity，此 Activity不会被打开
                        2- 应用的常规应用流程中存在的 Activity，创建返回栈，并打开 Activity
                2-- 创建 PendingIntent 对象并调用 PendingIntent.getActivity() 方法关联Intent
                    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);
                3-- NotificationCompat.Builder 对象调用 setContentIntent(pendingIntent) 方法来添加点按操作
                4-- NotificationCompat.Builder 对象调用 setAutoCancel(true) 方法来在点击通知后移除通知
                5-- 示例代码 ：
                    createNotificationChannel();

                    Intent intent = new Intent(MainActivity.this, MyNotification.class);
                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                    PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this, 0, intent, 0);
                    /**
                     * 创建通知内容
                     * setContentTitle(getString(R.string.title)) ：设置通知的标题
                     * setContentText("This is Text") ：设置通知的正文
                     * setSmallIcon(R.mipmap.ic_launcher) ：设置通知小图标
                     * setPriority(NotificationCompat.PRIORITY_DEFAULT) ：设置通知优先级
                     * setStyle() ：设置通知的样式模板
                     * setAutoCancel(true) : 点按通知后自动移除通知
                     * setContentIntent(pendingIntent) : 添加点按操作
                     * */
                    NotificationCompat.Builder builder = new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                            .setSmallIcon(R.mipmap.ic_launcher)
                            .setContentTitle(getString(R.string.title))
                            .setContentText(getString(R.string.text))
                            .setAutoCancel(true)
                            .setContentIntent(pendingIntent)
                            .setPriority(NotificationCompat.PRIORITY_DEFAULT);
                    manager.notify(1, builder.build());
        5】进阶用法
            1）播放音乐
                1-- NotificationCompat.Builder 对象的 setSound() 方法
                2-- 参数为Uri对象，调用 Uri.fromFile(音频路径) 作为setSound()参数
            2）震动
                1-- NotificationCompat.Builder 对象的 setVibrate() 方法
                2-- 参数为 long[] 单数下标表示手机震动的时间，双数下标(包括0)表示手机静止的时间(单位ms)
                    例如 ：setVibrate(new long[] {0, 1000, 1000, 1000})  表示通知发布后先静止0ms，再振动1s，再静止1s，再振动1s
                3-- 添加权限声明 ：<uses-permission android:name="android.permission.VIBRATE" />
            3）控制LED指示灯
                1-- NotificationCompat.Builder 对象的 setLights() 方法
                2-- 参数1 ：灯的颜色，例如Color.GREEN表示绿色
                    参数2 ：int类型数据，亮的时长（单位ms）
                    参数3 ：int类型数据，熄灭的时长（单位ms）
                  参数2 和 参数3 一起作用实现指示灯的闪烁
            4）使用默认效果
                1-- NotificationCompat.Builder 对象的 setDefaults() 方法
                2-- 参数为 NotificationCompat.DEFAULT_ALL
                这个设置会根据当前环境选择铃声、振动方式
        6】通知的高级功能
            1）setStyle() 方法 ：设置通知样式，允许我们构建富文本通知
                1-- 参数 ：NotificationCompat.Style 对象
                2-- 常见的使用方法
                    1-- 显示超长文本
                        .setStyle(new NotificationCompat.BigTextStyle().bigText(需要显示的文本))
                    2- 显示长图片
                        .setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResources(getResources(), 图片路径（例R.drawable.xxx）)))
                        BitmapFactory.decodeResources(getResources(), 图片路径（例R.drawable.xxx）) 用于将图片解析为 Bitmap对象

    2、调用摄像头和相册(最新的参考 cameralum)
        1】调用摄像头拍照
            1）请求相机功能
                1-- 应用依赖于相机（没有相机将无法运行），在 AndroidManifest.xml 中添加声明
                    <uses-feature android:name="android.hardware.camera"
                                  android:required="true" />
                2-- 应用可以使用相机，但不使用可以运行其他功能
                    <uses-feature android:name="android.hardware.camera"
                            android:required="false"/>
                    此种情况下应调用 hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY) 检查相机的可用性

            2）使用相机应用拍照
               利用Intent启用相机,注意要判断是否Intent对象是否可以被使用
                    /**
                     * 此函数作用为打开相机
                     * takePictureIntent.resolveActivity() ：判断takePictureIntent是否能被处理，如果不能处理
                     * 强制使用此Intent对象的话会使程序崩溃
                     * */
                    private void dispatchTakePictureIntent() {
                        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
                            startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
                        }
                    }
              注意 ：到此处已经可以实现拍照功能，但是拍照后的照片无法保存和使用
            3）获取缩略图
                Android相机应用会对返回Intent（作为extra中的小型Bitmap传递给 onActivityResult()，使用键 "data"）中的照片进行编码
                示例代码 ：
                    /**
                     * 此函数为启动其他 Activity 后返回此 Activity 的处理函数
                     * 先根据 requestCode 确定从哪个活动返回
                     * 再根据 resultCode 判断返回结果
                     * 然后在 （Intent）data 中用键 “data” 取出照片的省略图
                     * */
                    @Override
                    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
                        super.onActivityResult(requestCode, resultCode, data);
                        switch (requestCode) {
                            case REQUEST_IMAGE_CAPTURE:
                                if (resultCode == RESULT_OK) {
                                    Bundle bundle = data.getExtras();
                                    Bitmap imageBitmap = (Bitmap) bundle.get("data");
                                    picture.setImageBitmap(imageBitmap);
                                }
                        }
                    }
            4）保存完整尺寸的照片
                1-- 申请相机使用权限 ：<uses-permission android:name="android.permission.CAMERA" />
                2-- 相机运行时权限申请 ：
                    /**
                     * 相机运行时权限获取
                     * */
                    private void checkPermissionAndCamera() {
                        int hasCameraPermission = ContextCompat.checkSelfPermission(getApplication(),
                                Manifest.permission.CAMERA);
                        if (hasCameraPermission == PackageManager.PERMISSION_GRANTED) {
                            //有权限，调起相机拍照。
                            dispatchTakePictureIntent();
                        } else {
                            //没有权限，申请权限。
                            ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.CAMERA},
                                    PERMISSION_CAMERA_REQUEST_CODE);
                        }
                        Log.d("MainActivity", "checkPermissionAndCamera succeed");
                    }
                3-- 运行时函数申请回调函数 ：判断权限是否被允许
                    /**
                     * 申请运行时函数的回调函数
                     * */
                    @Override
                    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
                        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                        switch (requestCode) {
                            case PERMISSION_CAMERA_REQUEST_CODE:
                                if (grantResults.length > 0
                                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                                    //允许权限，有调起相机拍照。
                                    dispatchTakePictureIntent();
                                } else {
                                    //拒绝权限，弹出提示框。
                                    Toast.makeText(this,"拍照权限被拒绝",Toast.LENGTH_LONG).show();
                                }
                                break;
                            default:
                                break;
                        }
                        Log.d("MainActivity", "onRequestPermissionsResult succeed");
                    }
                4-- 创建相关全局属性
                    1- 判断 android 版本是否是Android 10以上
                         private boolean isAndroidQ = Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q;
                    2- 保存图片的uri ：private Uri mCameraUri;
                    3- 保存图片的文件路径，Android 10以下使用图片路径访问图片 ：private String mCameraImagePath;
                5-- 调起相机拍照
                     /**
                     * 此函数作用为打开相机
                     * takePictureIntent.resolveActivity() ：判断takePictureIntent是否能被处理，如果不能处理
                     * 强制使用此Intent对象的话会使程序崩溃
                     * photoFile = createImageFile(); : 获取图片文件路径名
                     * 此处要注意 ：android10以下用图片路径访问保存，android10及以上用图片uri来访问
                     * */
                    private void dispatchTakePictureIntent() {
                        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
                            File photoFile = null;
                            Uri photoUri = null;

                            if (isAndroidQ) {
                                // 适配android 10
                                photoUri = createImageUri();
                            } else {
                                try {
                                    photoFile = createImageFile();
                                } catch (IOException e) {
                                    e.printStackTrace();
                                }
                                if (photoFile != null) {
                                    mCameraImagePath = photoFile.getAbsolutePath();
                                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                                        //适配Android 7.0文件权限，通过FileProvider创建一个content类型的Uri
                                        photoUri = FileProvider.getUriForFile(this, getPackageName() + ".fileprovider", photoFile);
                                    } else {
                                        photoUri = Uri.fromFile(photoFile);
                                    }
                                }
                            }

                            mCameraUri = photoUri;
                            if (photoUri != null) {
                                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoUri);
                                takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
                                startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
                            }
                        }
                    }
                6-- 创建图片地址uri,用于保存拍照后的照片 Android 10以后使用这种方法
                    private Uri createImageUri() {
                        String status = Environment.getExternalStorageState();
                        // 判断是否有SD卡,优先使用SD卡存储,当没有SD卡时使用手机存储
                        if (status.equals(Environment.MEDIA_MOUNTED)) {
                           return getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, new ContentValues());
                        } else {
                            return getContentResolver().insert(MediaStore.Images.Media.INTERNAL_CONTENT_URI, new ContentValues());
                        }
                    }
                7-- 创建保存图片的文件（路径）
                     /**
                     * 此函数作用为 ：为照片创建文件
                     * getExternalFilesDir() ：创建一个共享文件夹
                     * */
                    private File createImageFile() throws IOException {
                        // 创建一个唯一的 image 名称
                        String imageName = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(new Date());
                        File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
                        if (!storageDir.exists()) {
                            storageDir.mkdir();
                        }
                        File tempFile = new File(storageDir, imageName);
                        if (!Environment.MEDIA_MOUNTED.equals(EnvironmentCompat.getStorageState(tempFile))) {
                            return null;
                        }
                        return tempFile;
                    }
                8-- 在调用相机后的回调函数中接收拍照结果和显示图片
                    /**
                     * 此函数为启动其他 Activity 后返回此 Activity 的处理函数
                     * 先根据 requestCode 确定从哪个活动返回
                     * 再根据 resultCode 判断返回结果
                     * 然后在 （Intent）data 中用键 “data” 取出照片的省略图
                     * */
                    @Override
                    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
                        super.onActivityResult(requestCode, resultCode, data);
                        switch (requestCode) {
                            case REQUEST_IMAGE_CAPTURE:
                                if (resultCode == RESULT_OK) {
                                    if (isAndroidQ) {
                                        // Android 10 使用图片uri加载
                                        picture.setImageURI(mCameraUri);
                                    } else {
                                        // 使用图片路径加载
                                        picture.setImageBitmap(BitmapFactory.decodeFile(mCameraImagePath));
                                    }
                                } else {
                                    Toast.makeText(this, "取消", Toast.LENGTH_LONG).show();
                                }
                                break;
                            default:
                                break;
                        }
                    }
                  关于 7-- 和 8-- ：Android 10由于文件权限的关系，显示手机储存卡里的图片不能直接使用图片路径，需要使用图片uri加载。
                9-- 配置文件共享
                    <provider
                        android:name="androidx.core.content.FileProvider"
                        android:authorities="${applicationId}.provider"
                        android:exported="false"
                        android:grantUriPermissions="true">
                        <meta-data
                            android:name="android.support.FILE_PROVIDER_PATHS"
                            android:resource="@xml/file_paths"/>
                    </provider>

                10-- 在res目录下创建文件夹xml ，放置一个文件file_paths.xml(文件名可以随便取)，配置需要共享的文件目录，也就是拍照图片保存的目录。
                     和 9-- 的 android:resource="@xml/file_paths" 对应
                        <?xml version="1.0" encoding="utf-8"?>
                        <paths xmlns:android="http://schemas.android.com/apk/res/android">
                        <external-files-path
                            name="my_images"
                            path="Android/data/com.example.cameraalbum/files/Pictures"/>
                        </paths>
                11-- 将图片放在共享储存区需要申请文件读写权限 ：（写权限默认同意读权限）
                    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
                    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
        2】在相册中选择图片
            1）打开系统的文件选择器 ：
                此处设置过滤器，只打开允许显示的图片文件
                // 打开文件选择器
                Intent intent = new  Intent(Intent.ACTION_OPEN_DOCUMENT);
                intent.addCategory(Intent.CATEGORY_OPENABLE);
                // 指定只显示图片
                intent.setType("image/*");
                startActivityForResult(intent, fromAlbum);
            2）调用getData()方法获取图片Uri
                Bitmap bitmap = getBitmapFromUri(data.getData());
                imageView.setImageBitmap(bitmap);  // 设置显示图片
            3）将图片Uri转换成Bitmap显示图片
                // 转换成Bitmap对象
                private Bitmap getBitmapFromUri(Uri uri) throws FileNotFoundException {
                    ParcelFileDescriptor r = getContentResolver().openFileDescriptor(uri, "r");
                      return   BitmapFactory.decodeFileDescriptor(r.getFileDescriptor());
                }

    3、播放多媒体(需要运行时权限)
        1】播放音乐 ：MediaPlayer 类
            1）常用的控制方法
                方法名                             功能描述
                setDataSource()             设置要播放的音频文件的文字
                prepare()                   在开始播放之前调用，完成准备工作
                start()                     开始或继续播放音频
                pause()                     暂停播放音频
                reset()                     将MediaPlayer重置到刚刚创建的状态
                seekTo()                    从指定的位置开始播放音频
                stop()                      停止播放音频，调用后MediaPlayer对象无法再次播放音频
                release()                   释放与MediaPlayer对象相关的资源
                isPlaying()                 判断当前MediaPlayer是否在播放音频
                getDuration()               获取载入的音频文件的时长
            2）MediaPlayer 工作流程
                1-- 创建一个 MediaPlayer 对象
                2-- 调用 setDataSource() 方法设置音频文件的路径
                3-- 调用 prepare() 方法使 MediaPlayer 进入准备状态
                4-- 调用 start() 方法开始播放音频
                5-- 调用 pause() 方法暂停播放
                6-- 调用 reset() 方法停止播放
            3）我们可以在项目工程中创建一个 assets 目录，在这个目录中可以存放任意文件及子目录，他们会打包到打包文件中，
            他和java、res 目录平级，需要创建在 module名/src/main 目录下
            4）完成播放或者关闭时需要关闭资源
        2】播放视频 ：VideoView 类
            1）常用方法 ：
                方法名                                 功能描述
                setVideoPath()                  设置需要播放的视频文件的位置
                start()                         开始或继续播放视频
                pause()                         暂停播放视频
                resume()                        将视频从头播放
                seekTo()                        从指定位置开始播放视频
                isPlaying()                     判断是否在播放视频
                getDuration()                   获取载入的视频时长
                getCurrentPosition()            获取当前进度，单位：ms
            2）注意 ：
                1-- VideoView 不支持直接播放 assets 目录下的视频资源
                  解决方案 ：res 目录允许再创建一个 raw 目录，可以讲音视频放在此目录下，并且可以直接播放
                2-- 注意路径名称的连接
                Uri uri = Uri.parse("android.resource://com.example.playvideotest/"+R.raw.video);

            3）完成播放或者关闭时需要关闭资源

九、服务-Service
    1、简介 ：Service 是 Android 实现后台程序运行的解决方案，它适合那些后台任务(不需要占用用户界面)。
            Service并不是一个独立的进程，它依赖创建 Service 时的进程，进程被销毁 Service 也会停止。
            Service 并不会自己创建子线程，所以我们需要在 Service 中创建子线程，避免主线程堵塞。
    2、Android 多线程编程
        1】线程的基本用法 ：
            1）创建一个类继承 Thread ，重写父类 run() 方法，在其中编写具体的逻辑
                class MyThread extends Thread() {
                    @override
                    public void run() {
                        // 具体的逻辑
                    }
                }
            2）使用 ：创建该类的实例，调用 start() 方法
                    new MyThread().start();
        2】利用接口来实现 ：
            1）使用实现 Runnable 接口的方式定义一个线程
                class MyThread implements Runnable() {
                    @override
                    public void run() {
                        // 具体的逻辑
                    }
                }
            2）是用这种方式时的启动方法
                MyThread myThread = new MyThread();
                new Thread(myThread).start();
        3】使用匿名类的方式
            new Thread(new Runnable() {
                @Override
                public void run() {
                    // 具体处理逻辑
                }
            }).start();

        4】在子线程中更新UI
            1）Android 在子线程中更新 UI 是不安全的，需要在主线程中更新
                经测试 ：在子线程中直接更新UI会导致程序崩溃
            2）解决方案 ：Android 提供了一套异步消息处理机制，可以实现子进程更新UI

        5】解析异步消息处理机制
            1）简介 ：android 中的异步消息处理机制主要由4部分组成 ：Message、Handler、MessageQueue、Looper，
            2）依次介绍 ：
                1-- Message
                    Message 是在线程之间传递消息，内部可以携带少量消息，what、arg1、arg2可以携带整形数据，obj可以携带object对象
                2-- Handler
                    Handler 主要用于发送和处理消息，发送消息主要使用 Handler 的 sendMessage() 方法，消息发出后最终会传递到Handler的handlerMessage() 方法中
                3-- MessageQueue
                    MessageQueue--消息队列，用于存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理，每个线程中只能有一个MessageQueue对象
                4-- Looper
                    Looper 是每个线程中的 MessageQueue 管家，调用 Looper 的loop() 方法后，会进入到无限循环中，会将发现的MessageQueue消息取出，并传递到Handler的
            3）异步消息处理流程 ：
                1-- 在主线程中创建一个 Handler 对象，重写handleMessage()方法
                2-- 需要进行相关操作时，创建Message对象，通过Handler将消息发送出去
                3-- 消息会被添加到 MessageQueue 的队列中等待被处理，Looper会一直尝试从MessageQueue取出消息
                4-- 最后，分发会Handler的handleMessage()方法中执行相关操作
                注意 ：此时的操作实际上是在主线程中执行，子线程只是发送了执行操作的消息
        6】使用 AsyncTask
            1）简介 ：AsyncTask 是基于异步消息处理机制的从子线程切换到主线程的工具
            2）基本用法 ：AsyncTask 是一个抽象类，束腰创建一个类去继承它
                1-- 继承时可以指定的三个参数 ：
                    Params ：执行 AsyncTask 时需要传入的参数，用于在后台任务中使用
                    Progress ：在后台任务执行时，使用这个泛型作为需要显示的进度的进度单位
                    Result ：任务执行完毕后，使用这一泛型来指定返回结果类型
                  简单示例 ：
                    class DownloadTask extends AsyncTask<void, Integer, Boolean> {
                        ...
                    }
                    解读 ：
                    void : 表示不需要传入参数
                    Integer ：表示整形数据作为进度显示单位
                    Boolean ：表示执行结束后的返回结果为布尔类型
                2-- 常用方法 ：
                    onPreExecute() :
                        在后台任务开始之前调用，用于进行界面上的初始化操作，例如 : 显示进度条
                    doInBackground(Params...) ：
                        这个方法在子线程中运行，在此方法中处理所有耗时任务，通过return将任务处理完之后的执行结果返回，
                      如果 AsyncTask 第三个参数为void，则不用返回。这个方法不能进行UI更新（UI更新调用publishProgress(Progress...)）
                    onProgressUpdate(Progress...) ：
                        当后台任务调用了 publishProgress() 方法后调用此方法，在这个方法中可进行UI操作以及更新界面元素，接收的参数为后台任务传递的参数
                    onPostExecute(Result) :
                        当后台任务执行完毕通过return返回结果时，会调用此方法，返回数据将作为参数传递进来，可以完成一些UI操作
                3-- 完整自定义 AsyncTask 的写法 （参考 DownloadTask.java）
                4-- 具体运行流程 ;
                    在 doInBackground(Params...) 中执行具体耗时任务，在 onProgressUpdate(Progress...) 方法中进行UI操作，在
                  onPostExecute(Result) 中执行任务的收尾工作
                5-- 启动此任务
                    new DownloadTask().execute();
                    注意 ：如果有入口参数可以传入，参数传递到 execute() 中，它会被传递到 doInBackground(Params...)中
    3、服务的基本用法
        1】定义一个Service
            1）右键 包名 -> New -> Service -> Service
            2）相关解释 ：
                Exported ：是否允许外部程序访问
                Enabled ：是否启用这个 Service
            3）常用方法 ：
                1-- onCreate() :
                    此方法会在Service创建时调用
                2-- onStartCommand() ：
                    在每次Service启动时调用，将处理逻辑编写在此方法中
                3-- onDestroy()
                    在 Service 销毁时调用，在销毁Service时在此方法在回收资源
            4）注意 ：Service需要在注册文件中注册才能生效

        2】启动和停止 Service ：借助 Intent启动
            1）开始 Service
                Intent intent = new Intent(MainActivity.this, MyService.class);
                startService(intent);  // 启动服务
            2）停止 Service
                Intent intent = new Intent(MainActivity.this, MyService.class);
                stopService(intent); // 停止服务
                在 Service 中停止 Service ：在Service内部调用stopSelf()方法
            注意 ：当应用程序不再前台时，后台Service会不稳定，可能被系统回收
        3】Service 与 Activity 进行通信
            1）创建一个专门的 Binder 类来管理
                在这个类中实现相关操作，然后创建它的实例
            2）在 onBind() 方法中将实例返回
            3）创建 ServiceConnection 匿名类 ：在服务绑定与解绑时运行
                private ServiceConnection connection = new ServiceConnection() {
                    @Override
                    public void onServiceConnected(ComponentName name, IBinder service) {
                        // 成功绑定时调用
                        // 获取 DownloadBinder 实例，可以调用对应方法来管理服务
                        downloadBinder = (MyService.DownloadBinder) service;
                        downloadBinder.startDownload();
                        downloadBinder.getProgress();
                    }

                    @Override
                    public void onServiceDisconnected(ComponentName name) {
                        // 解除绑定时调用
                    }
                };
            4）绑定 与 解绑 服务
                1-- 绑定服务 ：
                    Intent bindIntent = new Intent(MainActivity.this, MyService.class);
                    bindService(bindIntent, connection, BIND_AUTO_CREATE);  // 绑定服务
                    bindService方法解读 ：
                        第一个参数 ：Intent对象
                        第二个参数 ：ServiceConnection 对象
                        第三个参数 ：标志位，BIND_AUTO_CREATE表示绑定后自动创建服务，执行onCreate(),但不执行onStartCommand()方法
                2-- 解除绑定 ：
                    unbindService(connection);  // 解绑服务
            5）代码暂存（后续已被修改）
                public class MyService extends Service {

                private DownloadBinder mBinder = new DownloadBinder();

                class DownloadBinder extends Binder {

                    public void startDownload() {
                        Log.d("MyService", "startDownload");
                    }

                    public int getProgress() {
                        Log.d("MyService", "getProgress");
                        return 0;
                    }
                }

                public MyService() {
                }

                @Override
                public IBinder onBind(Intent intent) {
                    return mBinder;
                }

                @Override
                public void onCreate() {
                    super.onCreate();
                    Log.d("MyService", "Create");
                }

                @Override
                public int onStartCommand(Intent intent, int flags, int startId) {
                    Log.d("MyService", "start");
                    return super.onStartCommand(intent, flags, startId);
                }

                @Override
                public void onDestroy() {
                    super.onDestroy();
                    Log.d("MyService", "Destroy");
                }
            }
    4、Service 的生命周期
        1】首次调用Context的startService()方法时，会调用onCreate()方法，然后回调onStartCommand()方法
        2】后续每次调用Context的startService()方法都只会调用onStartCommand()方法
        3】多次调用startService()方法只会有一个Service实例，只需要关闭一次即可
        4】调用bindService()来获取一个Service的持久连接，此时会回调onBind()方法
        5】调用方会获取onBind()返回的IBinder对象来进行通信
        6】当调用stopService()时会回调Service的onDestroy()方法然后Service被销毁
        7】解除绑定时调用unbindService()时也会调用onDestroy()方法
        8】当Service被同时调用过startService()和bindService()后需要被销毁时，需要停止Service和解除绑定才能销毁
    5、Service 的更多技巧
        1】前台Service
            1）简介 ：前台Service能够一直保持运行状态，它一直会有一个正在运行的图标显示在系统通知栏
                @Override
                public void onCreate() {
                    super.onCreate();
                    Log.d("MyService", "Create");
                    NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        NotificationChannel channel = new NotificationChannel("my_service", "前台任务", NotificationManager.IMPORTANCE_DEFAULT);
                        manager.createNotificationChannel(channel);
                   }
                    Intent intent = new Intent(this, MainActivity.class);
                    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
                    Notification notification = new NotificationCompat.Builder(this, "my_service")
                            .setContentTitle("content title")
                            .setContentText("content text")
                            .setSmallIcon(R.drawable.ic_launcher_background)
                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_background))
                            .setContentIntent(pi)
                            .setProgress(100, 50, false)  // 显示进度条（第三个参数为动态会静态设置）
                            .build();
                    startForeground(1, notification);
                }
                解读 ：
                    1-- 前台Service会显示在通知栏上，所以需要构建 Notification 对象设定相关属性，然后通过startForeground()方法显示，
                    2-- startForeground() ：
                            参数1 ：通知的ID
                            参数2 ：Notification 对象
            2）从Android 9.0系统开始，使用前台Service需要在注册文件中声明权限
                <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
        2】使用 IntentService
            1）简介 ：Service默认是在主线程中运行的，因此我们需要在Service的具体方法中开启子线程执行耗时操作
            2）比较标准的Service形式 ：
                public int onStartCommand(Intent intent, int flags, int startId) {
                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                // 耗时操作
                            }
                        }).start();
                        return super.onStartCommand(intent, flags, startId);
                    }
            3）为了简单的创建一个异步、会自动停止的Service，Android专门提供了 IntentService类
                public class MyIntentService extends IntentService {
                    public MyIntentService() {
                        super("MyIntentService");  // 调用父类的构造函数
                    }

                    @Override
                    protected void onHandleIntent(@Nullable Intent intent) {
                        // 打印当前线程id
                        Log.d("MyIntentService", String.valueOf(Thread.currentThread().getId()));
                    }

                    @Override
                    public void onDestroy() {
                        super.onDestroy();
                        Log.d("MyIntentService", "Destroy");
                    }
                }
                解读 ：
                    1-- 需要在构造函数中调用父类构造方法
                    2-- 在 onHandleIntent() 方法中执行耗时操作，他已经处于子线程中了
                    3-- 结束时他会自动停止(运行完耗时逻辑就会停止，Service会被销毁)

十、使用网络技术
    1、WebView 的基础用法
        1】简介 ：WebView 可以在应用中嵌入一个浏览器，使用它可以加载网页
        2】简单用法 ：
            1）在布局文件中添加 WebView 控件并设置id（可其他常规控件相同）
            2）编辑相关属性 :
                WebView webView = findViewById(R.id.webView);
                webView.getSettings().setJavaScriptEnabled(true);
                webView.setWebViewClient(new WebViewClient());
                webView.loadUrl("https://www.baidu.com");
                解读 ：
                    1-- 通过 webView.getSettings() 方法可以设置浏览器的一些属性，此处 setJavaScriptEnabled(true) 表示支持javaScript脚本
                    2-- webView.setWebViewClient(new WebViewClient())  ：当需要打开一个网页时，目标网页仍然在当前WebView中显示，而不是打开系统浏览器
                    3-- webView.loadUrl("https://www.baidu.com") ：传入网址，打开指定网址
            3）在注册完文件中加入权限声明 ：
                <uses-permission android:name="android.permission.INTERNET"/>
    2、使用HTTP访问网络(参考 networktest)
        1】使用 HttpURLConnection
            1）简单用法 ：
                1-- 获取 HttpURLConnection 实例，创建一个URL对象，传入网络地址，最后调用openConnection()方法
                        URL url = new URL("https://www.baidu.com");
                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                2-- 获取实例后可以设置HTTP请求所使用的方法
                    GET : 表示希望从服务器获取数据
                    POST : 表示希望提交数据给服务器
                    写法 ：connection.setRequestMethod("GET");
                3-- 自由定制 ：例如设置连接超时、读取超时（单位ms）
                    connection.setConnectTimeout(5000);  // 连接超时
                    connection.setReadTimeout(5000);  // 读取超时
                4-- 调用 getInputStream() 方法就可以获取服务器返回的输入流了，接下来就是对数据流的读取
                    InputStream input = connection.getInputStream();
                5-- 最后调用 disconnect() 方法关闭HTTP连接
                    connection.disconnect();
            2）案例 ：
                新控件 ：ScrollView--实现滚动查看超出屏幕范围的内容
                1-- 在点击事件中调用自定义方法 ：
                    该方法作用是开启子线程发送HTTP请求，然后利用 BufferedReader 对服务器返回的流进行读取，然后将结果返回
                  自定义的showResponse()方法中开启子线程更新UI（此处用runOnUiThread()更新UI）。
                2-- 声明权限 ：
                    <uses-permission android:name="android.permission.INTERNET"/>
                3-- 如果需要提交数据 ：
                    将请求方式改为 POST， 并在获取输入流之前写入数据即可，每条数据都要以键值对的形式存在，数据与数据之间用 “&”符号隔开
                    例 ：
                        connection.setRequestMethod("POST");
                        DataOutputStream out = new DataOutputStream(connection.getOutputStream());
                        out.writeBytes("username=admin&password=123456");
        2】使用OkHttp
            1）在构造文件中添加依赖库
                implementation 'com.squareup.okhttp3:okhttp:4.1.1'
            2）基础使用 ：
              发起GET请求 ：
                1-- 首先创建一个 OkHttpClient 的实例 : OkHttpClient client = new OkHttpClient();
                2-- 发起HTTP请求前需要创建一个Request对象 ：Request request = new Request.Builder().build();
                3-- 上述Request对象为空对象，我们可以在build()方法调用前使用其他方法来丰富它
                        Request request = new Request.Builder()
                                    .url("https://www.baidu.com")  // 绑定网址
                                    .build();
                4-- 调用OkHttpClient的newCall()方法来创建一个Call对象并调用它的execute()方法发送请求并获取服务器返回的数据
                        Response response = client.newCall(request).execute();
                5-- 获取返回的具体内容 ：String responseData = response.body().toString();
              发起POST请求 ：
                第2、3步有差异，如下 ：
                2-- 创建一个RequestBody对象来存储数据，数据以键值对方式储存 ：
                        RequestBody requestBody = new FormBody.Builder()
                                        .add("username", "admin")
                                        .add("password", "123456")
                                        .build();
                3-- 构建Request对象时调用post()方法，并传入RequestBody对象 ：
                        Request request = new Request.Builder()
                                        .url("https://www.baidu.com")
                                        .post(requestBody)
                                        .build();
    3、解析XML格式数据
        前言 ：每个访问网络的应用程序都有一个自己的服务器，我们可以向服务器提交数据，也可以从服务器获取数据。
                网络上传输的数据一般都是经过格式化的，这种数据有一定的结构规格语义，当一方接收到后可以按照相同的
                结构规格进行解析从而提取出信息。
        1】搭建一个简单的web服务器提供一段XML文本，然后我们去访问他进行解析
            1）在这里选择 Apache 服务器，安装教程报百度即可
            3）进入安装位置的 htdocs 目录下，新建get_data.xml文件，加入如下XML格式内容
                <apps>
                	<app>
                		<id>1</id>
                		<name>Google Maps</name>
                		<version>1.0</version>
                	</app>
                	<app>
                		<id>2</id>
                		<name>Chrome</name>
                		<version>2.1</version>
                	</app>
                	<app>
                		<id>3</id>
                		<name>Google Play</name>
                		<version>2.3</version>
                	</app>
                </apps>
        2】Pull解析方式
            private void parseXMLWithPull(String xmlData) {
                try {
                    // 获取XmlPullParserFactory实例
                    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
                    // 获取XmlPullParser对象
                    XmlPullParser xmlPullParser = factory.newPullParser();
                    // 将获取的 XML数据设置进去
                    xmlPullParser.setInput(new StringReader(xmlData));
                    // 得到当前解析的事件getEventType()
                    int eventType = xmlPullParser.getEventType();
                    String id = "";
                    String name = "";
                    String version = "";
                    while (eventType != xmlPullParser.END_DOCUMENT) {  // 判断解析工作是否完成
                        String nodeName = xmlPullParser.getName();  // 获取当前节点的名字
                        switch (eventType) {
                            // 开始解析某个节点
                            case XmlPullParser.START_TAG :
                                if ("id".equals(nodeName)) {
                                    id = xmlPullParser.nextText();  // 获取节点的具体内容
                                } else if ("name".equals(nodeName)) {
                                    name = xmlPullParser.nextText();
                                } else if ("version".equals(nodeName)) {
                                    version = xmlPullParser.nextText();
                                }
                                break;
                            // 完成解析某个点
                            case XmlPullParser.END_TAG:
                                if ("app".equals(nodeName)) {
                                    Log.d("MainActivity","id:"+id);
                                    Log.d("MainActivity","name:"+name);
                                    Log.d("MainActivity","version:"+version);
                                }
                                break;
                            default:
                                break;
                        }
                        eventType = xmlPullParser.next();  // 获取下一个解析事件
                    }
                }catch (Exception e) {
                    e.printStackTrace();
                }
            }
        3】SAX解析方式
            1）简介 ：SAX解析的用法比Pull复杂，但是语义更加清楚
            2）新建一个类继承DefaultHandler，重写父类的相关方法
                public class MyHandler extends DefaultHandler{
                    @Override
                    public void startDocument() throws SAXException {
                        super.startDocument();
                    }

                    @Override
                    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
                        super.startElement(uri, localName, qName, attributes);
                    }

                    @Override
                    public void characters(char[] ch, int start, int length) throws SAXException {
                        super.characters(ch, start, length);
                    }

                    @Override
                    public void endElement(String uri, String localName, String qName) throws SAXException {
                        super.endElement(uri, localName, qName);
                    }

                    @Override
                    public void endDocument() throws SAXException {
                        super.endDocument();
                    }
                }
            3）方法解读 ：
                1-- startDocument() : 此方法在开始解析XML的时候调用
                2-- startElement() ：此方法开始解析某个节点时调用
                3-- characters() ：此方法会在获取节点中的内容时调用
                    获取节点内容时，此方法会被多次调用，一些换行符也被当作内容解析出来
                4-- endElement() ：此方法完成节点解析后调用
                5-- endDocument() ：此方法在完成整个XML解析后调用
            4）具体方法的代码查看java类（MyHandler.java）,下列是完整的解析流程 ：
                SAXParserFactory factory = SAXParserFactory.newInstance();
                XMLReader xmlReader = factory.newSAXParser().getXMLReader();
                使用此类 ：
                1-- 创建类的实例
                    MyHandler handler = new MyHandler();
                2-- 将上述实例设置到XMLReader中去
                    xmlReader。setContentHandler(handler);
                3-- 开始解析
                    xmlReader.parse(new InputSource(new StringBuilder(xmlData)));
    4、解析JSON数据
        1】简介 ：JSON体积小，网络传输更省流量。但是语义性较差，看起来不如XML直观
        2】使用JSONObject解析
            private void pareseJSONWithJSONObject(String jsonData) throws JSONException {
                    JSONArray jsonArray = new JSONArray(jsonData);
                    for (int i = 0; i<jsonArray.length(); i++) {
                        JSONObject jsonObject = jsonArray.getJSONObject(i);
                        String id = jsonObject.getString("id");
                        String name = jsonObject.getString("name");
                        String version = jsonObject.getString("version");
                        Log.d("MainActivity", "id"+id);
                        Log.d("MainActivity", "name"+name);
                        Log.d("MainActivity", "version"+version);

                    }
                }
        3】使用GSON解析
            1）添加依赖 ：implementation 'com.google.code.gson:gson:2.8.5'
            2）简介 ：GSON可以将一段JSON字符的字符串自动映射成一个对象
                1-- 例 ：解析JSON字段 {"name":"Tom","age":"20"}
                    我们可以定义一个Person类然后加入name和age字段，然后调用一下代码即可 ：
                        Gson gson = new Gson();
                        Person person = gson.fromJson(jsonData, Person.class);
                2-- 解析JSON数组 ：
                    需要借助TypeToken将期望解析成的数据类型传入fromJson()方法中，例 ：
                        List<Preson> Person = gson.fromJson(jsonData, new TypeToken<List<Person>>(){}.getType());
                    案例 ：解析JSON数组
                        [{"id":"5",""version":"5.5","name":"Clash of clans"},
                        {"id":"6",""version":"7.0","name":"Boom Beach"},
                        {"id":"7",""version":"3.5","name":"Clash Royale"}]
                        1- 创建一个App类，添加id、name、version字段，并加入对应get、set方法
                        2- 解析部分 ：
                            Gson gson = new Gson();
                            List<App> appList = gson.fromJson(jsonData, new TypeToken<List<App>>(){}.getType());
                            for (App app : appList) {
                                // 此时以获取对象可进行对应操作
                            }

十一、使用蓝牙、NFC和WI-FI点对点进行通信
    1、使用蓝牙传输数据
        1】简介 ：使用蓝牙API，可以搜索、连接指定范围内的其他蓝牙设备。使用Bluetooth Socket可以初始化一条通信链路，可以在
                设备间传输数据。本教程只支持加密通信，只能在已配对的设备间进行连接。
        2】管理本地蓝牙适配器
            1）简介 ：本地蓝牙适配器通过 BluetoothAdapter 类控制
            2）访问默认的蓝牙适配器 ：getDefaultAdapter() 方法
                例 ：BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
            3）关于权限 ：
                1-- 读取本地蓝牙适配器的属性、启动发现或查找绑定的设备
                    <uses-permission android:name="android.permission.BLUETOOTH"/>
                2-- 蓝牙扫描可以获取用户的位置信息
                    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
                3-- 需要在运行时申请位置权限
                    if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION)
                            != PackageManager.PERMISSION_GRANTED) {
                        ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.ACCESS_COARSE_LOCATION}
                                , PERMISSION_LOCATION);
                    }
                4-- 如果需要修改蓝牙的相关属性
                    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
            4）相关方法
                1-- 判断设备是否启用 ：isEnabled()
                2-- 获取设备名称和硬件地址 ：getName()、getAddress()
                3-- 设置设备名称：setName()   需要 BLUETOOTH_ADMIN 权限
                4-- 获取当前蓝牙适配器状态 ：getState(),返回的常量 ：
                    STATE_TURNING_ON  STATE_TURNING_OFF  STATE_ON  STATE_OFF
                5-- 开启蓝牙 ：将 F 静态常量用作startActivityForResult动作来请求用户开启蓝牙
                    startActivityForResult(new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE), 1);
        3】可被发现和远程设备发现
            1）简介 ：两台设备彼此查找并连接的过程称为发现。在建立Bluetooth Socket通信之前，本地的蓝牙适配器必须和远程设备绑定。
                    在两台设备绑定并连接之前，他们必须发现彼此。
            2）使设备可被发现
                1-- 可被发现性由扫描模式显示，调用 BluetoothAdapter 的 setScanMode()方法来获取
                    返回的参数 ：
                        1- SCAN_MODE_CONNECTABLE_DISCOVERABLE : 查询扫描和页面扫描都开启。设备能被任何一台设备扫描到。
                        2- SCAN_MODE_CONNECTABLE : 页面扫描已启用，但查询扫描未启用。设备可以被已配对过的设备扫描到。
                        3- SCAN_MODE_NONE : 可被发现性关闭，所有设备都不能发现
                    Android默认关闭可发现性，需要使用 ACTION_REQUEST_DISCOVERABLE 动作打开一个新的Activity来获取权限
                        private void enable_discoverable() {  // 开启可被发现性
                                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
                                startActivityForResult(intent, DISCOVERY_REQUEST);
                            }
                    可被发现性回调函数（部分）
                        case DISCOVERY_REQUEST :  // 请求可被发现回调
                            if (resultCode != RESULT_CANCELED) {
                                // 可被发现性已打开
                                Toast.makeText(this, "可被发现"+resultCode, Toast.LENGTH_SHORT).show();
                            } else {
                                Toast.makeText(this, "不可被发现", Toast.LENGTH_SHORT).show();
                            }
                        resultCode ：表示可被发现性持续时长，单位:秒(s)
                        RESULT_CANCELED ：表示拒绝开启可被发现模式
            3）发现远程设备
                1-- 如果要去发现一台新设备，那么需要本地蓝牙适配器启动发现扫描
                2-- 如果需要使用蓝牙的相关信息确定位置信息，必须在运行时中申请 ACCESS_COARSE_LOCATION 权限
                3-- 使用isDiscovering() 方法判断是否在进行发现扫描
                4-- 开启发现扫描 ：调用 BluetoothAdapter 对象的 startDiscovery() 方法
                    发现过程是异步的，Android会在发现过程开始和结束时将Intent广播出去，同时也会将扫描到的远程设备告知你
                5-- 创建广播接收器来监听 ACTION_DISCOVERY_STARTED 和 ACTION_DISCOVERY_FINISHED 广播Intent
                6-- 发现的蓝牙设备会通过发送 ACTION_FOUND 广播Intent来返回
                7-- 每个发现的蓝牙设备返回的广播 Intent 包含设备名称，存放在Extra信息的BluetoothDevice.EXTRA_NAME字段中
                        获取 ：String remoteDeviceName = intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
                    还包含代表着设备不可变得Parcelable对象，存放在Extra信息的BluetoothDevice.EXTRA_DEVICE字段中
                        获取 ：BluetoothDevice remoteBevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        4】蓝牙通信
            1）简介 ：
                1-- 两台设备必须先配对才能通信
                2-- 建立通信信道进行双向通信的两个类 ：
                    BluetoothServerSocket ：监听连接
                        用来监听套接字，初始化设备间的链路。其中一台设备将作为服务器监听和接收进入的请求连接，以建立握手。
                    BluetoothSocket ：初始化新的信道和处理信道
                        用来创建新的客户端，连接正在监听的服务器，在建立连接后被服务器返回。一旦建立连接，服务器和客户端都将使用
                      BluetoothSocket来传输数据流。
                  客户端和服务器只影响建立连接，建立之后的数据传递是完全一致的。
            2）打开 Bluetooth Service Socket 监听器
                1-- 简介 ：Bluetooth Service Socket 用于监听连接请求，此时设备扮演服务器的角色
                2-- 设置设备为服务器 ：调用 listenUsingRfcommWithServiceRecord() 方法来监听连接请求，可以传入名称（用于标识服务器）和
                  通用唯一识别码。（UUID）注意 ：UUID随机生成不能自己设定
                    String name = "My Device";
                    UUID uuid = UUID.randomUUID();
                    BluetoothServerSocket bluetoothServerSocket = bluetoothAdapter.listenUsingRfcommWithServiceRecord(name, uuid);
                3-- 客户端需要知道服务器的UUID才能连接
                4-- 设置好监听器后调用accept方法会开始监听。调用时可以传入超时时间，服务器会阻塞，知道有尝试建立连接，客户端必须拥有相匹配的UUID
                5-- 当连接请求来自一台没有配对的远程设备，那么需要配对后才能返回accept调用
                6-- 连接成功后会返回一个连接设备的Bluetooth Socket，可以用来传输数据
                注意 ：监听为阻塞操作，需要放在子线程中使用
                7-- 设备必须是可被发现的。使用 ACTION_REQUEST_DISCOVERABLE 广播请求使设备变为可被发现的，然后开始监听连接请求
                例 ：
                    private BluetoothAdapter bluetoothAdapter=BluetoothAdapter.getDefaultAdapter();  // 定义蓝牙适配器
                    private BluetoothSocket bluetoothSocket;  // 建立连接的Bluetooth Socket

                    // 监听蓝牙连接
                    private UUID startServiceSocket() {
                        String name = "bluetoothService";
                        UUID uuid = UUID.randomUUID();
                        try {
                            final BluetoothServerSocket bluetoothServerSocket = bluetoothAdapter.listenUsingRfcommWithServiceRecord(name, uuid);
                            new Thread(new Runnable() {
                                @Override
                                public void run() {
                                    try {
                                        // 监听连接
                                        bluetoothSocket = bluetoothServerSocket.accept();
                                        // 开始监听信息
                                        listenForMessages();
                                    } catch (IOException e) {
                                        e.printStackTrace();
                                    }
                                }
                            }).start();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        return uuid;
                    }

                    // 接收信息
                    private void listenForMessages() {
                        // 接收消息逻辑
                    }
            2）选择远程蓝牙设备进行通信
                1-- 创建客户端Bluetooth Socket对象，需要先获取远程设备服务器的 BluetoothDevice 对象
                2-- 可以创建的前提条件 ：
                    1- 远程设备可以被发现
                    2- 远程设备正在监听连接
                    3- 本地设备与远程设备必须先完成配对
                3-- BluetoothDevice对象是远程设备的代理，通过他们可以查找远程设备的属性以及初始化Bluetooth Socket连接
                4-- 获取 BluetoothDevice 对象的方法 ：
                    1- 进行设备扫描时接收到的广播Intent含有此对象信息bluetoothAdapter
                    2- 本地设备通过远程设备的蓝牙地址查询 ：BluetoothDevice device = bluetoothAdapter.getRemoteDevice("01:23:97:35:2F:AA");
                    3- 获取已配对设备，调用getBondedDevices()方法来获取，返回的是一个Set集合
                        Set<BluetoothDevice> bluetoothDevices = bluetoothAdapter.getBondedDevices();
            3）开启客户端 Bluetooth Socket 连接
                1-- 使用远程设备初始化通信信道，需要调用远程设备(BluetoothDevice对象)的createRfcommSocketToServiceRecord()方法创建Bluetooth Socket，
                  同时传入对应已经开启的Bluetooth Service Socket监听器和UUID
                2-- 然后调用创建的Bluetooth Socket对象的connect()方法来连接(此操作也是阻塞操作，需要在子线程中完成)
                    // 连接远程设备
                    private void connectToServiceSocket(BluetoothDevice device, UUID uuid) {
                        try {
                            // 获取BluetoothSocket对象
                            BluetoothSocket clientSocket = device.createRfcommSocketToServiceRecord(uuid);
                            // 开始尝试连接
                            clientSocket.connect();
                            // 开始接收信息
                            listenForMessages();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
            4）使用 Bluetooth Socket 传输数据
                1-- 建立连接后就可以Bluetooth Socket来传输数据
                2-- 数据的传输通过 InputStream 和 OutputStream 对象来完成的
                    1- 这两个对象获取 ：通过 grtInputStream() 和 getOutputStream() 方法获取
                    2- 发送信息 ：通过OutputStream对象的write()方法，参数为byte类型 (类似于单片机中的char数据)取值范围-128~127，
                                可以通过getByte()方法来将内容装换为Byte类型
                    3- 接受信息 ：通过 InputStream 对象的 read() 方法来读取
            5）蓝牙的配置文件
                上述通用办法之外，蓝牙规范提供了一个用于在特定类型和目的设备间通信的专用接口 ：
                    1-- 耳机 ：BluetoothHeadset 类用于宿主设备与蓝牙耳机之间的通信
                    2-- A2DP（高级音频分发设备） ：BluetoothA2DP类
                    3-- 健康设备 ：相关配置文件
                1-- 使用方式 ：
                    1- 调用 BluetoothAdapter 实例的 getProfileProxy() 方法调用相关配置文件（使用相关配置文件）
                        getProfileProxy()方法参数 ：
                            参数1 ：上下文对象
                            参数2 ：BluetoothProfile.ServiceListener 的一个实现
                            参数3 ：对应的配置文件参数，例如 ：BluetoothProfile.HEADSET
                    2- 对应的远程连接建立连接时，Service Listener 的 onServiceConnected()方法会被调用，会提供用于和远程设备交互的代理对象
                        例 ：（BluetoothProfile.ServiceListener 的实现）
                            private BluetoothProfile.ServiceListener listener = new BluetoothProfile.ServiceListener() {
                                @Override
                                public void onServiceConnected(int profile, BluetoothProfile proxy) {
                                    // 连接后的回调函数，需要对proxy进行强制类型转换后在使用
                                }

                                @Override
                                public void onServiceDisconnected(int profile) {
                                    // 断开连接时调用
                                }
                            };
                    3- 使用完毕后需要关闭配置文件 ：调用 BluetoothAdapter 实例的 closeProfileProxy() 方法
                         closeProfileProxy()参数 ：
                            参数1 ：对应的配置文件参数，例如 ：BluetoothProfile.HEADSET
                            参数2 ：提供的用于和远程设备交互的代理对象
        5】低功耗蓝牙
            1）简介 ：低功耗蓝牙传输数据的数据量更小，消耗的能量更少，适合物联网设备。它的连接基于查找外设和广播自身外设。
            2）外设需要中央设备才能互相通信
            3）关于通信 ：
                1-- 使用 Bluetooth Adapter 进行传统蓝牙通信
                2-- 搜索外设时 ：
                    使用 Bluetooth Adapter 的 getBluetoothLeScanner() 方法接收一个 BluetoothLeScanner 对象，然后调用
                  startScan() 方法开始扫描BLE设备，同时传入一个 ScanCallback 实现
                    例 ：
                        private void BLEScan() {
                            bluetoothAdapter.getBluetoothLeScanner().startScan(new ScanCallback() {
                                @Override
                                public void onScanResult(int callbackType, ScanResult result) {
                                    super.onScanResult(callbackType, result);

                                    BluetoothDevice device = result.getDevice();  // 获取设备对象
                                }
                            });
                        }
                    解读 :
                        onScanResult 方法接收一个 ScanResult 对象，可以通过它获取 BluetoothDevice 对象，实现与远程BLE的交互

十二、WIFI学习
    1、WLAN扫描
        1】WLAN 扫描流程
            1）注册 SCAN_RESULTS_AVAILABLE_ACTION 广播监听器，系统在完成扫描请求时调用此监听器，应用可以使用广播被动监听设备上所有扫描的完成情况
            2）调用 WifiManager.startScan() 方法请求扫描，需要判定方法的返回状态，下列情况可能导致失败 ：
                1-- 短时间扫描过多，扫描请求可能遭到节流
                2-- 设备处于空闲状态，扫描已停用
                3-- WLAN 硬件报告扫描失败
            3）调用 WifiManager.getScanResults() 方法获取扫描结果，返回结果为最近更新的结果，如果扫描未完成或，可能返回上一次扫描的结果，
              所以需要在收到第一条中的广播后再获取结果。
        2】关于权限及版本
            1）Android 8.0 和 Android 8.1
                调用 WifiManager.getScanResults() 需要下列任意一项权限 ：
                    ACCESS_FINE_LOCATION
                    ACCESS_COARSE_LOCATION
                    CHANGE_WIFI_STATE
                如果应用不具备上述权限，调用将会失败，并显示 ：SecurityException。
                【*】在搭载 Android 8.0（API 级别 26）及更高版本的设备上，您可以使用 CompanionDeviceManager 代表应用对附近的配套设备执行扫描，而不需要位置权限。
            2）Android 9
                调用 WifiManager.startScan() 需要满足以下所有条件：
                    1-- 应用拥有 ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION 权限。
                    2-- 应用拥有 CHANGE_WIFI_STATE 权限。
                    3-- 设备已启用位置信息服务
            3）Android 10（API 级别 29）及更高版本
                成功调用 WifiManager.startScan() 需要满足以下所有条件：
                    1-- 如果应用以 Android 10（API 级别 29）SDK 或更高版本为目标平台，需要拥有 ACCESS_FINE_LOCATION 权限
                    2-- 如果应用以低于 Android 10（API 级别 29）的 SDK 为目标平台，需要拥有 ACCESS_COARSE_LOCATION 或 ACCESS_FINE_LOCATION 权限
                    3-- 应用拥有 CHANGE_WIFI_STATE 权限
                    4-- 设备已启用位置信息服务
                成功调用 WifiManager.getScanResults() 需要满足以下所有条件：
                    1-- 应用以 Android 10（API 级别 29）SDK 或更高版本为目标平台，应用需要拥有 ACCESS_FINE_LOCATION 权限
                    2-- 应用以低于 Android 10（API 级别 29）的 SDK 为目标平台，应用需要拥有 ACCESS_COARSE_LOCATION 或 ACCESS_FINE_LOCATION 权限
                    3-- 应用拥有 ACCESS_WIFI_STATE 权限
                    4-- 设备已启用位置信息服务
                调用应用无法满足上述所有要求，调用将失败，并显示:SecurityException
        3】节流 ：扫描频率限制
            1）Android 8.0 和 Android 8.1
                每个后台应用可以在 30 分钟内扫描一次
            2）Android 9
                每个前台应用可以在 2 分钟内扫描四次。这样便可在短时间内进行多次扫描。
                所有后台应用总共可以在 30 分钟内扫描一次。
            3）Android 10 及更高版本
                适用 Android 9 的节流限制。新增一个开发者选项，用户可以关闭节流功能以便进行本地测试（位于开发者选项 > 网络 > WLAN 扫描调节下）。
        4】示例代码 ：
            // 获取WifiManager对象
            WifiManager wifiManager = (WifiManager)context.getSystemService(Context.WIFI_SERVICE);
            // 初始化广播接收器
            BroadcastReceiver wifiScanReceiver = new BroadcastReceiver() {
              @Override
              public void onReceive(Context c, Intent intent) {
                boolean success = intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false);
                if (success) {
                  scanSuccess();
                } else {
                  // scan failure handling
                  scanFailure();
                }
              }
            };

            IntentFilter intentFilter = new IntentFilter();
            // 添加监听动作
            intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
            // 注册广播监听器
            context.registerReceiver(wifiScanReceiver, intentFilter);
            // 获取扫描状态
            boolean success = wifiManager.startScan();
            if (!success) {
              // scan failure handling
              scanFailure();
            }

            ....

            private void scanSuccess() {
              // 获取扫描信息
              List<ScanResult> results = wifiManager.getScanResults();
              ... use new scan results ...
            }

            private void scanFailure() {
              // handle failure: new scan did NOT succeed
              // consider using old scan results: these are the OLD results!
              List<ScanResult> results = wifiManager.getScanResults();
              ... potentially use older scan results ...
            }
    2、WLAN 直连（对等连接或 P2P）
        1】简介 ：使用 WLAN 直连 (P2P) 技术，可以让具备相应硬件的 Android 4.0（API 级别 14）或更高版本设备在没有中间接入点的情况下，
            通过 WLAN 进行直接互联。使用这些 API，您可以实现支持 WLAN P2P 的设备间相互发现和连接，从而获得比蓝牙连接更远距离的高速连接通
            信效果。对于多人游戏或照片共享等需要在用户之间共享数据的应用而言，这一技术非常有用。
        2】主要内容 ：
            1）支持发现、请求，以及连接到对等设备的方法（在 WifiP2pManager 类中定义）。
            2）支持获知 WifiP2pManager 方法调用成功与否的侦听器。调用 WifiP2pManager 方法时，每个方法均可收到作为参数传入的特定侦听器。
            3）通知 WLAN P2P 框架检测到的特定事件（例如连接断开或新发现对等设备）的 Intent
        3】API概述 ：
            WifiP2pManager 类提供的方法使您可以在设备上与 WLAN 硬件交互，以执行发现和连接对等设备等操作。
            1） WLAN P2P 方法
                    方法                                  说明
                initialize()	        通过 WLAN 框架注册应用。必须先调用此方法，然后再调用任何其他 WLAN P2P 方法。
                connect()	            启动与具有指定配置的设备的对等连接。
                cancelConnect()	        取消任何正在进行的对等群组协商。
                requestConnectInfo()	请求设备连接信息。
                createGroup()	        以群组所有者的身份，使用当前设备创建对等群组。
                removeGroup()	        移除当前对等群组。
                requestGroupInfo()	    请求对等群组信息。
                discoverPeers()	        启动对等设备发现
                requestPeers()	        请求已发现对等设备的当前列表。
            WifiP2pManager 方法使您可以在侦听器中进行传递，以便 WLAN P2P 框架可以向您的 Activity 通知通话状态。
            2） WLAN P2P 侦听器
                        侦听器接口	                            相关操作
                WifiP2pManager.ActionListener	        connect()、cancelConnect()、createGroup()、removeGroup() 和 discoverPeers()
                WifiP2pManager.ChannelListener	        initialize()
                WifiP2pManager.ConnectionInfoListener	requestConnectInfo()
                WifiP2pManager.GroupInfoListener	    requestGroupInfo()
                WifiP2pManager.PeerListListener	        requestPeers()
            3）WLAN P2P Intent
            WLAN P2P API 定义当发生特定 WLAN P2P 事件时会广播的 Intent
                            Intent	                                说明
                WIFI_P2P_CONNECTION_CHANGED_ACTION	    当设备的 WLAN 连接状态更改时广播。
                WIFI_P2P_PEERS_CHANGED_ACTION	        当调用 discoverPeers() 时广播。如果在应用中处理此 Intent，则通常需要调用 requestPeers() 以获取对等设备的更新列表。
                WIFI_P2P_STATE_CHANGED_ACTION	        当 WLAN P2P 在设备上启用或停用时广播。
                WIFI_P2P_THIS_DEVICE_CHANGED_ACTION	    当设备的详细信息（例如设备名称）更改时广播。
        4】为 WLAN P2P Intent 创建广播接收器
            1）创建扩展 BroadcastReceiver 类的类。对于类的构造函数，您很可能希望具备 WifiP2pManager、WifiP2pManager.Channel，以及此广播接收器将在其中注册的 Activity 的参数。
              这使广播接收器可以向 Activity 发送更新，访问 WLAN 硬件并获得通信通道（如果需要）。
            2）在广播接收器中，查看您感兴趣的 Intent onReceive()。根据接收到的 Intent，执行任何必要操作。例如，如果广播接收器接收到 WIFI_P2P_PEERS_CHANGED_ACTION Intent，则您
              可以调用 requestPeers() 方法，以获得当前所发现对等设备的列表。
        5】示例代码 :
            /**
             * A BroadcastReceiver that notifies of important Wi-Fi p2p events.
             */
            public class WiFiDirectBroadcastReceiver extends BroadcastReceiver {

                private WifiP2pManager mManager;
                private Channel mChannel;
                private MyWiFiActivity mActivity;
                // 构造方法
                public WiFiDirectBroadcastReceiver(WifiP2pManager manager, Channel channel,
                        MyWifiActivity activity) {
                    super();
                    this.mManager = manager;
                    this.mChannel = channel;
                    this.mActivity = activity;
                }

                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    // 判断接收到的广播动作（建议用switch语句）
                    if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) {
                        // Check to see if Wi-Fi is enabled and notify appropriate activity
                    } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) {
                        // Call WifiP2pManager.requestPeers() to get a list of current peers
                    } else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) {
                        // Respond to new connection or disconnections
                    } else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) {
                        // Respond to this device's wifi state changing
                    }
                }
            }
        6】相关方法调用
            通过 Android Q，以下广播 Intent 已从粘性变为非粘性：
            1）WIFI_P2P_CONNECTION_CHANGED_ACTION
                应用可使用 requestConnectionInfo()、requestNetworkInfo() 或 requestGroupInfo() 来检索当前连接信息。
            2）WIFI_P2P_THIS_DEVICE_CHANGED_ACTION
                应用可使用 requestDeviceInfo() 来检索当前连接信息。

        7】创建 WLAN P2P 应用
            创建 WLAN P2P 应用涉及为应用创建并注册广播接收器、发现对等设备，连接到对等设备，以及将数据传输到对等设备。以下部分将介绍如何完成此操作。
            1）初始化设置
                在使用 WLAN P2P API 之前，您必须确保您的应用可以访问硬件，并且设备支持 WLAN P2P API 协议。如果设备支持 WLAN P2P，您可以获得 WifiP2pManager
              的实例，创建并注册广播接收器，然后开始使用 WLAN P2P API。
                1-- 请求在设备上使用 WLAN 硬件的权限，同时声明您的应用在 Android 清单中具有正确的最低 SDK 版本 ：
                    <uses-sdk android:minSdkVersion="14" />
                    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
                    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
                    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
                    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
                    <uses-permission android:name="android.permission.INTERNET" />
                    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
                    还需要启动位置信息，否则无法调用以下API：discoverPeers、discoverServices、requestPeers
                2-- 检查 WLAN P2P 是否开启并受支持。在广播接收器收到 WIFI_P2P_STATE_CHANGED_ACTION 的 Intent 时，在接收器中进行检查
                    示例 ：
                        @Override
                        public void onReceive(Context context, Intent intent) {
                        ...
                        String action = intent.getAction();
                        if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) {
                            int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
                            if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) {
                                // Wifi P2P is enabled
                            } else {
                                // Wi-Fi P2P is not enabled
                            }
                        }
                        ...
                        }
                3-- 在 Activity 的 onCreate() 方法中，获取 WifiP2pManager 的实例，并通过调用 initialize()，在 WLAN P2P 框架中注册您的
                  应用。此方法会返回 WifiP2pManager.Channel，用于将您的应用连接到 WLAN P2P 框架。此外，您还应该通过 WifiP2pManager 和
                  WifiP2pManager.Channel 对象以及对 Activity 的引用，创建广播接收器实例。这样广播接收器便可通知 Activity 感兴趣的事件并
                  进行相应更新。此外，您还可以操纵设备的 WLAN 状态（如有必要）：
                    示例 ：
                        WifiP2pManager manager;
                        Channel channel;
                        BroadcastReceiver receiver;
                        ...
                        @Override
                        protected void onCreate(Bundle savedInstanceState){
                            ...
                            manager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
                            channel = manager.initialize(this, getMainLooper(), null);
                            receiver = new WiFiDirectBroadcastReceiver(manager, mChannel, this);
                            ...
                        }
                4-- 创建 Intent 过滤器，然后添加与广播接收器检查内容相同的 Intent：
                    示例 ：
                        IntentFilter intentFilter;
                        ...
                        @Override
                        protected void onCreate(Bundle savedInstanceState){
                            ...
                            intentFilter = new IntentFilter();
                            intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
                            intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
                            intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
                            intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
                            ...
                        }
                5-- 在 Activity 的 onResume() 方法中注册广播接收器，然后在 Activity 的onPause() 方法中取消注册该接收器：
                    示例 ：
                        /* 注册 */
                        @Override
                        protected void onResume() {
                            super.onResume();
                            registerReceiver(mReceiver, intentFilter);
                        }
                        /* 取消注册 */
                        @Override
                        protected void onPause() {
                            super.onPause();
                            unregisterReceiver(mReceiver);
                        }
                获取 WifiP2pManager.Channel 并设置广播接收器后，应用便可调用 WLAN P2P 方法并收到 WLAN P2P Intent。
        8】发现对等设备
            调用 discoverPeers()，以检测范围内的可用对等设备。对此功能的调用为异步操作，如果您已创建 WifiP2pManager.ActionListener，
          则系统会通过 onSuccess() 和 onFailure() 告知应用成功与否。onSuccess() 方法仅会通知您发现进程已成功，但不会提供有关其发现的
          实际对等设备（如有）的任何信息：
            示例 ：
                manager.discoverPeers(channel, new WifiP2pManager.ActionListener() {
                    @Override
                    public void onSuccess() {
                        ...
                    }

                    @Override
                    public void onFailure(int reasonCode) {
                        ...
                    }
                });
            如果发现进程成功并检测到对等设备，则系统会广播 WIFI_P2P_PEERS_CHANGED_ACTION Intent，您可以在广播接收器中侦听该 Intent，
          以获取对等设备列表。当应用接收到 WIFI_P2P_PEERS_CHANGED_ACTION Intent 时，您可以通过 requestPeers() 请求已发现对等设备的列表。
            示例 ：
                PeerListListener myPeerListListener;
                ...
                if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) {

                    // request available peers from the wifi p2p manager. This is an
                    // asynchronous call and the calling activity is notified with a
                    // callback on PeerListListener.onPeersAvailable()
                    if (manager != null) {
                        manager.requestPeers(channel, myPeerListListener);
                    }
                }
            requestPeers() 方法也为异步操作，并可在对等设备列表可用时通过。
            onPeersAvailable()（定义见 WifiP2pManager.PeerListListener 接口）通知您的 Activity。
            onPeersAvailable() 方法为您提供 WifiP2pDeviceList，您可对其进行迭代以查找希望连接的对等设备。
        9】连接到对等设备
            获取可能对等设备的列表，且已确定您要连接的设备后，调用connect() 方法即可连接到相应设备。调用此方法需要使用 WifiP2pConfig 对象，
          其中包含要连接的设备的信息。您可以通过 WifiP2pManager.ActionListener 获知连接是否成功。以下代码展示如何创建与所需设备的连接：
            示例 ：
                //obtain a peer from the WifiP2pDeviceList
                WifiP2pDevice device;
                WifiP2pConfig config = new WifiP2pConfig();
                config.deviceAddress = device.deviceAddress;
                manager.connect(channel, config, new ActionListener() {

                    @Override
                    public void onSuccess() {
                        //success logic
                    }

                    @Override
                    public void onFailure(int reason) {
                        //failure logic
                    }
                });
        10】传输数据
            建立连接后，您可以通过套接字在设备之间传输数据。数据传输的基本步骤如下：
            1）创建 ServerSocket。此套接字会在指定端口等待来自客户端的连接，然后加以屏蔽直到连接发生，因此请在后台线程中也执行此操作。
            2）创建客户端 Socket。客户端使用 IP 地址和服务器套接字端口连接到服务器设备。
            3）将数据从客户端发送到服务器。客户端套接字成功连接到服务器套接字后，您可以通过字节流将数据从客户端发送到服务器。
            4）服务器套接字等待客户端连接（通过 accept() 方法）。在客户端连接前，此调用会屏蔽连接，所以这是另一个线程。发生连接时，
            服务器设备可接收到客户端数据。对这些数据执行任何操作，例如将其保存到文件中，或向用户显示这些数据。
          以下示例（修改自 WLAN P2P 演示示例）展示如何创建此客户端-服务器套接字通信，以及如何通过服务将 JPEG 图像从客户端传输到服务器。如需完整工作示例，请编译并运行 WLAN P2P 演示示例。
            public static class FileServerAsyncTask extends AsyncTask {

                private Context context;
                private TextView statusText;

                public FileServerAsyncTask(Context context, View statusText) {
                    this.context = context;
                    this.statusText = (TextView) statusText;
                }

                @Override
                protected String doInBackground(Void... params) {
                    try {

                        /**
                         * Create a server socket and wait for client connections. This
                         * call blocks until a connection is accepted from a client
                         */
                        ServerSocket serverSocket = new ServerSocket(8888);
                        Socket client = serverSocket.accept();

                        /**
                         * If this code is reached, a client has connected and transferred data
                         * Save the input stream from the client as a JPEG file
                         */
                        final File f = new File(Environment.getExternalStorageDirectory() + "/"
                                + context.getPackageName() + "/wifip2pshared-" + System.currentTimeMillis()
                                + ".jpg");

                        File dirs = new File(f.getParent());
                        if (!dirs.exists())
                            dirs.mkdirs();
                        f.createNewFile();
                        InputStream inputstream = client.getInputStream();
                        copyFile(inputstream, new FileOutputStream(f));
                        serverSocket.close();
                        return f.getAbsolutePath();
                    } catch (IOException e) {
                        Log.e(WiFiDirectActivity.TAG, e.getMessage());
                        return null;
                    }
                }

                /**
                 * Start activity that can handle the JPEG image
                 */
                @Override
                protected void onPostExecute(String result) {
                    if (result != null) {
                        statusText.setText("File copied - " + result);
                        Intent intent = new Intent();
                        intent.setAction(android.content.Intent.ACTION_VIEW);
                        intent.setDataAndType(Uri.parse("file://" + result), "image/*");
                        context.startActivity(intent);
                    }
                }
            }
            在客户端上，通过客户端套接字连接到服务器套接字，然后传输数据。本示例传输的是客户端设备文件系统中的 JPEG 文件。
                示例 ：
                    Context context = this.getApplicationContext();
                    String host;
                    int port;
                    int len;
                    Socket socket = new Socket();
                    byte buf[]  = new byte[1024];
                    ...
                    try {
                        /**
                         * Create a client socket with the host,
                         * port, and timeout information.
                         */
                        socket.bind(null);
                        socket.connect((new InetSocketAddress(host, port)), 500);

                        /**
                         * Create a byte stream from a JPEG file and pipe it to the output stream
                         * of the socket. This data is retrieved by the server device.
                         */
                        OutputStream outputStream = socket.getOutputStream();
                        ContentResolver cr = context.getContentResolver();
                        InputStream inputStream = null;
                        inputStream = cr.openInputStream(Uri.parse("path/to/picture.jpg"));
                        while ((len = inputStream.read(buf)) != -1) {
                            outputStream.write(buf, 0, len);
                        }
                        outputStream.close();
                        inputStream.close();
                    } catch (FileNotFoundException e) {
                        //catch logic
                    } catch (IOException e) {
                        //catch logic
                    }

                    /**
                     * Clean up any open sockets when done
                     * transferring or if an exception occurred.
                     */
                    finally {
                        if (socket != null) {
                            if (socket.isConnected()) {
                                try {
                                    socket.close();
                                } catch (IOException e) {
                                    //catch logic
                                }
                            }
                        }
                    }
    3、WLAN 感知概览
        1】简介 ：WLAN 感知功能使搭载 Android 8.0（API 级别 26）及更高版本的设备能够发现彼此并直接进行连接，它们之间无需任何其他类型的连接。
            WLAN 感知也称为“邻近感知网络”(NAN)。
                WLAN 感知网络的工作原理是与邻近设备组建集群，如果设备是某个区域的第一个设备，则创建一个新集群。此集群行为适用于整个设备，由
            WLAN 感知系统服务管理；应用无法控制集群行为。应用使用 WLAN 感知 API 与 WLAN 感知系统服务通信，后者管理设备上的 WLAN 感知硬件。
        2】应用可通过 WLAN 感知 API 实现操作 ：
            1）发现其他设备 ：
                    此 API 具有查找其他附近设备的机制。此过程会在一台设备发布一项或多项可发现服务时启动。然后，当设备订阅一项或多项服务并进入
                发布者的 WLAN 范围时，订阅者会收到一条告知已发现匹配发布者的通知。在订阅者发现发布者后，订阅者可以发送短消息或与发现的设备建立
                网络连接。设备可以既是发布者又是订阅者。
            2）创建网络连接 ：
                    两台设备发现彼此后，可以创建没有接入点的双向 WLAN 感知网络连接。
            与蓝牙连接相比，WLAN 感知网络连接支持的覆盖范围更广，支持的吞吐率更高。这些类型的连接适用于在用户之间共享大量数据的应用，例如照片共享应用。
      运用部分 :
        1】初始设置：
            1）申请权限
                <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
                <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
                <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
            2）使用 PackageManager API 检查设备是否支持 WLAN 感知功能
                context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
            3）检查 WLAN 感知功能当前是否可用。设备上可能存在 WLAN 感知功能，但当前可能无法使用，因为用户已停用 WLAN 或位置信息服务。如果正在使用 WLAN
            直连、SoftAP 或网络共享，某些设备可能不支持 WLAN 感知功能，具体取决于其硬件和固件功能。要检查 WLAN 感知功能当前是否可用，请调用 isAvailable()。
                WLAN 感知功能的可用性随时都可能发生变化。应用应注册 BroadcastReceiver 才能收到每当可用性发生变化时发送的 ACTION_WIFI_AWARE_STATE_CHANGED。
            应用收到该广播 Intent 后，应舍弃所有现有会话（假设 WLAN 感知服务已中断），然后检查当前的可用性状态并相应地调整其行为。
                代码示例 ：
                    WifiAwareManager wifiAwareManager =
                                (WifiAwareManager)context.getSystemService(Context.WIFI_AWARE_SERVICE)
                        IntentFilter filter =
                                new IntentFilter(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED);
                        BroadcastReceiver myReceiver = new BroadcastReceiver() {
                            @Override
                            public void onReceive(Context context, Intent intent) {
                                // discard current sessions
                                if (wifiAwareManager.isAvailable()) {
                                    ...
                                } else {
                                    ...
                                }
                            }
                        };
                        context.registerReceiver(myReceiver, filter);
        2】获取会话
            1）要开始使用 WLAN 感知功能，您的应用必须通过调用 attach() 获取 WifiAwareSession。此方法会执行以下操作：
                1-- 开启 WLAN 感知硬件
                2-- 加入或组建 WLAN 感知集群
                3-- 创建一个包含唯一命名空间的 WLAN 感知会话，该命名空间充当在其中创建的所有发现会话的容器
              应用成功附加，则系统会执行 onAttached() 回调。该回调提供了一个 WifiAwareSession 对象，应用应该将该对象用于所有后续会话操作。应用可以使用会话来发布服务或订阅服务。
              应用只能调用 attach() 一次。如果应用调用 attach() 多次，则应用会为每次调用接收不同的会话，且每个会话都有自己的命名空间。适用于复杂的情况，通常应该避免。
              【*】注意：只要有活动的会话，系统就会与 WLAN 感知集群保持同步。此集群操作会消耗资源和电量。为了节省资源，请在不再需要会话时调用 WifiAwareSession.close()。
        3】发布服务
            1）使服务可被检测到，需要调用采用下列参数的 publish() 方法：
                1-- PublishConfig 指定服务名称和其他配置属性，例如匹配过滤器。
                2-- DiscoverySessionCallback 指定发生事件时（例如订阅者收到消息时）要执行的操作。
            2）示例 ：
                PublishConfig config = new PublishConfig.Builder()
                        .setServiceName(“Aware_File_Share_Service_Name”)
                        .build();

                    awareSession.publish(config, new DiscoverySessionCallback() {
                        @Override
                        public void onPublishStarted(PublishDiscoverySession session) {
                            ...
                        }
                        @Override
                        public void onMessageReceived(PeerHandle peerHandle, byte[] message) {
                            ...
                        }
                    }, null);
            3）相关处理逻辑 ：
                1-- 如果发布成功，则会调用 onPublishStarted() 回调方法。
                2-- 发布后，当运行匹配订阅者应用的设备进入发布设备的 WLAN 范围时，订阅者会发现该服务
                3-- 当订阅者发现发布者时，发布者不会收到通知。
                4-- 订阅者向发布者发送消息，则发布者会收到通知，系统会调用 onMessageReceived() 回调方法，可以使用此方法的 PeerHandle 参数向订阅者回发消息或创建与订阅者的连接。
                5-- 调用 DiscoverySession.close() 可以关闭发布服务，如果不调用此方法，系统无法保证超出范围的会话何时关闭。
        4】订阅服务
            1）当需要订阅服务时，需要调用采用下列参数的 subscribe() 方法：
                1-- SubscribeConfig 指定要订阅的服务的名称和其他配置属性，例如匹配过滤器。
                2-- DiscoverySessionCallback 指定发生事件时（例如发现发布者时）要执行的操作。
            2）示例 ：
                SubscribeConfig config = new SubscribeConfig.Builder()
                        .setServiceName("Aware_File_Share_Service_Name")
                        .build();

                    awareSession.subscribe(config, new DiscoverySessionCallback() {
                        @Override
                        public void onSubscribeStarted(SubscribeDiscoverySession session) {
                            ...
                        }

                        @Override
                        public void onServiceDiscovered(PeerHandle peerHandle,
                                byte[] serviceSpecificInfo, List<byte[]> matchFilter) {
                            ...
                        }
                    }, null);
            3）相关处理逻辑 ：
                1-- 如果发布成功，则会调用 onPublishStarted() 回调方法。
                2-- 可以使用回调中的 SubscribeDiscoverySession 参数在应用发现发布者后与之进行通信，因此应该保存此引用。
                  就是用一个全局变量来保存这个对象实现持久通信。
                3-- 可以随时通过对发现会话调用 updateSubscribe() 来更新订阅会话。
                4-- 订阅者进入等待匹配的发布者的 WLAN 范围时，系统会执行 onServiceDiscovered() 回调方法。可以使用此回调中
                  的 PeerHandle 参数向该发布者发送消息或创建与该发布者的连接。
                5-- 调用 DiscoverySession.close() 可以关闭发布服务，如果不调用此方法，系统无法保证超出范围的会话何时关闭。
        5】发送消息
            1）前期准备（创建相关对象）
                1-- DiscoverySession 对象。此对象可以调用 sendMessage()。应用通过发布服务或订阅服务来获取 DiscoverySession。
                2-- 另一台设备的 PeerHandle，用于传送消息。应用通过以下两种方式之一获取另一台设备的 PeerHandle：
                    1- 应用发布服务并接收来自订阅者的消息。应用从 onMessageReceived() 回调中获取订阅者的 PeerHandle。
                    2- 应用订阅某项服务。然后，当发现匹配的发布者时，应用会从 onServiceDiscovered() 回调中获取发布者的 PeerHandle。
            2）发送消息 ：
                调用 sendMessage() 方法即可发送，但会发生以下回调 ：
                    1-- 当对等设备成功收到消息后，系统会在发送方应用中调用 onMessageSendSucceeded() 回调。
                    2-- 当对等设备收到消息后，系统会在接收方应用中调用 onMessageReceived() 回调。
                【*】注意：消息通常用于轻量级消息传递，因为它们可能无法送达（或无序送达、多次送达）且长度限制在大约 255 个字节。要确定确切的长度限制，
                  请调用 getMaxServiceSpecificInfoLength()。对于高速双向通信，您的应用应该改为 创建连接 。
                【*】虽然需要 PeerHandle 才能与对等设备进行通信，但您不应依赖它作为对等设备的永久标识符。应用可以使用更高级别的标识符，这些标识符嵌入
                  在发现服务本身或后续消息中。您可以使用 PublishConfig 或 SubscribeConfig 的 setMatchFilter() 或 setServiceSpecificInfo() 方法在发
                  现服务中嵌入标识符。setMatchFilter() 方法会影响发现，而 setServiceSpecificInfo() 方法不会影响发现。
                【*】在消息中嵌入标识符意味着修改消息字节数组以包含标识符（例如，作为前几个字节）。（只需要能够确定身份即可）
        6】创建连接
            1）简介 : WLAN 感知功能支持两个 WLAN 感知设备之间的客户端-服务器网络连接。
            2）实现操作 ：
                1-- 使用 WLAN 感知发现功能（在服务器上）发布服务并（在客户端上）订阅服务。
                2-- 订阅者发现发布者后，从订阅者向发布者发送消息。
                3-- 在发布者设备上启动 ServerSocket，并设置或获取其端口：
                    ServerSocket ss = new ServerSocket(0);
                    int port = ss.getLocalPort();
                4-- 使用 ConnectivityManager 和 WifiAwareNetworkSpecifier 在发布者设备上请求 WLAN 感知网络，指定发现会话和订阅者的 PeerHandle，后者
                  是您通过订阅者发送的消息获取的：
                    NetworkSpecifier networkSpecifier = new WifiAwareNetworkSpecifier.Builder(discoverySession, peerHandle)
                        .setPskPassphrase("somePassword")
                        .setPort(port)
                        .build();
                    NetworkRequest myNetworkRequest = new NetworkRequest.Builder()
                        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI_AWARE)
                        .setNetworkSpecifier(networkSpecifier)
                        .build();
                    ConnectivityManager.NetworkCallback callback = new ConnectivityManager.NetworkCallback() {
                        @Override
                        public void onAvailable(Network network) {
                            ...
                        }

                        @Override
                        public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                            ...
                        }

                        @Override
                        public void onLost(Network network) {
                            ...
                        }
                    };

                        ConnectivityManager connMgr.requestNetwork(networkRequest, callback);
                5-- 使用与发布者相同的方法在订阅者设备上请求 WLAN 感知网络。创建 NetworkSpecifier 时，请勿指定端口。当网络连接可用、已更改或丢失时，
                  系统会调用相应的回调方法。
                6-- 对订阅者调用 onAvailable() 方法之后，可以使用一个 Network 对象打开 Socket 以与发布者设备上的 ServerSocket 进行通信，但需要
                  知道 ServerSocket 的 IPv6 地址和端口。可以从 onCapabilitiesChanged() 回调中提供的 NetworkCapabilities 对象中获取这些信息：
                    WifiAwareNetworkInfo peerAwareInfo = (WifiAwareNetworkInfo) networkCapabilities.getTransportInfo();
                    Inet6Address peerIpv6 = peerAwareInfo.getPeerIpv6Addr();
                    int peerPort = peerAwareInfo.getPort();
                    ...
                    Socket socket = network.getSocketFactory().createSocket(peerIpv6, peerPort);
                7-- 完成网络连接后，请调用 unregisterNetworkCallback()。（注销网络回调）
        7】对等设备测距和位置感知发现
            1）简介 ：具有 WLAN RTT 位置功能的设备可以直接测量到对等设备的距离，并利用此信息限制 WLAN 感知服务发现。
                      WLAN RTT API 支持直接使用 WLAN 感知对等设备的 MAC 地址或 PeerHandle 测量到该设备的距离。
                      WLAN 感知发现功能可以被限制为仅发现特定地理围栏内的服务。例如，您可以设置地理围栏，以便发现发布
                  "Aware_File_Share_Service_Name" 服务且距离在 3 米（指定为 3000mm）到 10 米（指定为 10000mm）之间的设备。
            2）启用地理围栏的方法 ：
                1-- 发布者必须使用 setRangingEnabled(true) 对发布的服务启用测距。如果发布者未启用测距，则会忽略订阅者指定的任何地理围栏限制，
                  并执行正常发现而忽略距离。
                2-- 订阅者必须使用 setMinDistanceMm 和 setMaxDistanceMm 的某种组合来指定地理围栏。
                    对于任一值，未指定的距离表示没有限制。只指定最大距离意味着最小距离为 0。仅指定最小距离意味着没有最大值。
                如果在地理围栏内发现对等服务，则会触发 onServiceDiscoveredWithinRange 回调，从而提供与对等设备的测量距离。然后，可以根据需要调用直接 WLAN RTT API，以便稍后测量距离。

十三、Material Design 实践——最佳UI体验
    1、简介 ：一种全新的界面设计语言，包括视觉、运动、互动效果等特性
    2、Toolbar（参考toolbar module）
        1】简介 ：继承了 ActionBar 的所有功能（自定义控件标题栏的按钮），灵活性更高，初始的应用程序都会有显示 ActionBar（由于主题原因），
              所以我们需要指定一个不带 ActionBar 的主题（常见 ：Theme.AppCompat.NoActionBar(深色主题) 和 Theme.AppCompat.Light.NoActionBar（浅色主题））
            <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        2】需要重写颜色属性（含义参考mipmap/ToolBar.png）
            1）colorPrimary
            2）colorPrimaryDark
            3）colorAccent ：不只是用来指定按钮的颜色，表示强调的意思（例如：一些控件选中后也会使用这个颜色）
        3】相关解释
            <?xml version="1.0" encoding="utf-8"?>
            <FrameLayout
                xmlns:android="http://schemas.android.com/apk/res/android"
                xmlns:app="http://schemas.android.com/apk/res-auto"  // 指定命名空间，现在可以使用 app:attribute 的写法，但是为了兼容
                                                                        老系统，所以采用 app:attribute 写法（许多Material属性是在新系
                                                                        统中新增的，采取这种方法是为了兼容老系统）
                android:layout_width="match_parent"
                android:layout_height="match_parent">

                <androidx.appcompat.widget.Toolbar
                    android:id="@+id/toolbar"
                    android:layout_width="match_parent"
                    android:layout_height="?attr/actionBarSize"
                    android:background="@color/colorPrimary"
                    android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"  // 指定ToolBar的主题
                    app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>  // 指定菜单项的主题
            </FrameLayout>
        4】常用功能
            1）修改文字————在AndroidManifest.xml中修改
                <activity android:name=".MainActivity"
                            android:label="标题">
                如果不指定会采用默认的名称（应用名）
            2）添加 action 按钮

                <item
                        android:id="@+id/backup"
                        android:icon="@drawable/ic_launcher_background"
                        android:title="Backup"
                        app:showAsAction="always"/>  // 设置显示模式
                    always : 永远显示在 ToolBar 中
                    never ：显示在菜单栏中
                    ifRoom ：屏幕空间足够的话显示在 ToolBar 中，不够显示在菜单栏中
                    显示在ToolBar中 ：只显示图标
                    显示在菜单栏中 ：只显示文字
    3、滑动菜单(DrawerLayout)
        1】简介 ：将一些菜单选项隐藏起来，而不是放在主屏幕上，然后可以通过滑动的方式将菜单项显示出来
        2】DrawerLayout运用
            1）介绍 ：DrawerLayout 它是一个布局，布局中允许放入两个自接子控件，第一个子控件（布局）是主屏幕中显示的内容，第二个子控件（布局）
                    是滑动菜单中显示的内容。
            2）使用参考 drawerlayout module ，实现了右滑唤出菜单页（可添加多个控件，需要放在一个布局中）
            【*】注意 ：必须指定第二个布局或控件的 layout_gravity 属性，设置隐藏的方位（例如隐藏在左边或右边）
            3）滑动菜单目前只能滑动拉出，现在 加上一个按钮来唤出滑动菜单
                // 获取按钮的实例并设置属性
                ActionBar actionBar = getSupportActionBar();
                if (actionBar != null) {
                    actionBar.setDisplayHomeAsUpEnabled(true);  // 显示导航按钮
                    actionBar.setHomeAsUpIndicator(R.drawable.ic_launcher_background);  // 设置导航按钮图片
                }

                case android.R.id.home :
                    drawerLayout.openDrawer(GravityCompat.START);  // 按钮唤出滑动菜单
                    break;
        3】注意 ：原则上可以再滑动菜单中定制任意布局，但是建议使用下一小节的 navigationview

    4、NavigationView (滑动菜单的优化)
        1】这个控件是google对滑动菜单的优化，使用时需要加入依赖项 ：
            // 添加 Material 库，
            implementation 'com.google.android.material:material:1.0.0'
            // 开源项目 CircleImageView ：实现图片圆形化
            implementation 'de.hdodenhof:circleimageview:3.0.1'
        2】使用前我们需要准备：menu 和 headerLayout。前者用来在 NavigationView 中显示具体的菜单项，headerLayout用来在 NavigationView 中显示
         头部布局。
            1）创建 menu 文件(详细代码 menu 目录下的 nemu.xml)
                1. 首先在 <menu> 中嵌套 <group> 标签， 表示创建一个组
                2. 将 group 的 checkableBehavior 属性设置为 single ，表示组中的选项只能 单选
                    <group android:checkableBehavior="single">
                3. 创建 <item>（菜单项） 指定 id、图标、菜单项需要显示的文字
                    <item android:id="@+id/navCall"
                        android:icon="@drawable/call"
                        android:title="Call"/>

            2）准备 headerLayout（头部布局）--具体代码参考 nav_header.xml 文件
              此处示例在头部布局中显示头像、用户名、头像
                1. 在layout文件下下创建 nav_header.xml 文件
                2. 布局文件最外层是一个 RelativeLayout ，宽度为 match_parent（与父控件相同），高度为 180dp（较为合适）
                3. 在 RelativeLayout 中放置三个控件， CircleImageView 用来将图片圆形化（用来展示头像）；两个TextView，一个用来
                显示邮箱，一个现实用户名。
            3）获取 NavigationView 实例，然后调用 setCheckedItem 方法设置默认选项， 设置 setNavigationItemSelectedListener() 选择
             监听器来监听 menu 选择情况。
            4）注意 ：由于系统自带这有一个 ToolBar ，所以直接设置会报错，我们需要在清单中设置application的<theme>属性为NoActionBar
                <application
                    android:theme="@style/Theme.AppCompat.Light.NoActionBar"
                    />
    5、悬浮按钮和可交互提示
        1】悬浮按钮 ： FloatingActionButton
            1）简介 ：实现悬浮按钮效果，可以设置图标
            2）代码部分参考（navigationview 的 main_activity.xml） ：
                <com.google.android.material.floatingactionbutton.FloatingActionButton
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:id="@+id/fab"
                        android:layout_gravity="bottom|end"
                        android:layout_margin="16dp"
                        android:src="@drawable/task1"
                        app:elevation="8dp"/>  // 设置悬浮高度
            3）处理点击事件
                用法和普通按钮类似，通过添加点击事件监听器来捕获单击事件
        2】可交互提示 ： Snackbar
            1）简介 ：Snackbar允许在提示中加入一个可交互按钮，在按下按钮式会执行相关逻辑，用法和Toast类似，只是添加了
                点击事件。
            2）代码部分 （navigationview 的 MainActivity.java）：
                Snackbar.make(v, "data deleted", Snackbar.LENGTH_SHORT)
                        .setAction("Undo", new View.OnClickListener() {
                            @Override
                            public void onClick(View v) {
                                Toast.makeText(MainActivity.this, "undo succeed", Toast.LENGTH_SHORT).show();
                            }
                        }).show();
                Snackbar的make方法创建一个Snackbar对象实例，传入一个当前界面布局的view（会自动查找最外层的布局），进而展示Snackbar；
              第二个参数是显示内容；第三个参数是Snackbar显示的时长.
                第二步调用setAction()方法来设置一个动作，并在其中添加点击事件监听器，这样就可以与用户进行交互.
        3】CoordinatorLayout
            1）简介 ：CoordinatorLayout 可以监听所有子控件的各种事件，自动帮助我们做出最合理的响应。
            2）CoordinatorLayout 可以完全替换 FrameLayout，不会有任何副作用
            3）代码在 navigationview 的 main_activity.xml 中，替换前交互信息会遮挡悬浮按钮；替换后悬浮按钮会上浮（带有动画），
            不会被遮挡。
    6、卡片式布局
        1】CardView
            1）简介：实现卡片式布局效果，它实际上也是 FrameLayout ，只是额外的提供了圆角和阴影效果，有了立体的感觉
            2）简单使用 ：
                1- 第一步需要将需要的库导入 ： （原则上倒入第一个就可以实现了，建议第二个也导入）
                    implementation 'com.google.android.material:material:1.2.1'
                    implementation 'androidx.cardview:cardview:1.0.0'
                2- 添加卡片布局 <com.google.android.material.card.MaterialCardView>
                    通过 app:cardCornerRadius="4dp" 属性设置圆角大小
                    通过 app:elevation 设置高度（高度值越大投影范围越大，效果越淡）
                3- （本例实现瀑布流显示多个卡片布局，所以需要使用到 recyclerview 布局）需要导入依赖库
                    implementation 'androidx.recyclerview:recyclerview:1.1.0'
                    // 添加 recyclerview 布局的依赖库
                    implementation 'com.github.bumptech.glide:glide:4.9.0'
                    // 添加 glide 库的依赖，它是一个图片加载库，用于加载本地和网络上的图片
                4- 在主活动中的 CoordinatorLayout 布局中添加一个 RecyclerView 用来实现瀑布流布局
                        代码参考 activity_main.xml
                5- 创建一个java实体类Fruit用来在后续保存图片对象（name字段保存名称；iamgeId字段保存水果图片资源ID）
                        代码参考 Fruit.java 文件
                6- 为 RecyclerView 子项指定自定义布局,最外层布局为 MaterialCardView（卡片布局），子项采用线性布局，
                  主体是一个 ImageView 和 TextView ，用来显示图片及名称。
                    android:scaleType="centerCrop" ：指定图片的缩放模式（示例参数为保持原有比例填充满ImageView，并将
                  超出的部分裁减掉）
                7- 新建 FruitAdapter 类来作为 RecyclerView 的适配器，让这个适配器继承自 RecyclerView.Adapter，
                  将泛型指定为 FruitAdapter.ViewHolder
                        代码参考 FruitAdapter.java
                8- 在 MainActivity.java 中采用了 GridLayoutManager ，它第一个参数为 Context ，第二个为列数（每一行显示几列）
        2】AppBarLayout
            1）简介 ： AppBarLayout 是一个内部封装了很多滚动事件的垂直方向的LinearLayout
            2）在上一节中，RecyclerView 布局会遮盖住 ToolBar ，加入 AppBarLayout 可以解决这一问题
            3）用法 ：
                第一步将 ToolBar 嵌套到 AppBarLayout 中；第二步给 RecyclerView 指定一个布局行为
                (代码参考 activity_main.xml )
            4）AppBarLayout 中的子控件可以指定如何影响 Activity 中发生的事件（通过 app:layout_scrollFlags 属性来设置），例 ：
                app:layout_scrollFlags="scroll|enterAlways|snap"
                scroll ：ToolBar 在 RecyclerView 向上滚动时会一起滚动并隐藏
                enterAlways ：ToolBar 在 RecyclerView 向下滚动时会一起滚动并重新显示
                snap ：当 ToolBar 还没有完全隐藏和显示时，会根据当前滚动的距离，自动选择隐藏或显示
    7、下拉刷新
        1】简介 ： SwipeRefreshLayout 是实现下拉刷新的核心类，我们将需要实现下拉刷新的类放置在 SwipeRefreshLayout 中，
                就可以让这个控件实现下拉刷新
        2】简单用法 ：(代码参考 activity_main.xml )
            1）在布局文件中添加一个 SwipeRefreshLayout 组件，然后将需要实现下拉刷新的组件添加为它的子组件
            2）在 .java 代码中创建实例
                swipeRefresh = findViewById(R.id.swipeRefresh); // 获取实例
                swipeRefresh.setColorSchemeColors(R.color.colorPrimary);  // 设置下拉刷新进度条的颜色
                swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { // 设置下拉刷新的监听器
                    @Override
                    public void onRefresh() {  // 检测到下拉后调用
                        refreshFruits();
                    }
                });
    8、可折叠式标题栏（CollapsingToolBarLayout）
        1】CollapsingToolBarLayout
            1）简介 ：它是一个作用于 ToolBar 基础之上的布局，他让 ToolBar 效果变得更加丰富，但是它不能独立存在，必须
                作为 AppBarLayout 的直接子布局来使用， AppBarLayout 必须是 CoordinatorLayout 的子布局
            2）简单用法 ：
                1》 创建一个新的 Activity
                    1- 编写布局文件(水果标题栏) ：水果内容详情(代码参考 cardview（module）-> activity_fruit.xml)
                        ① 实现标题部分 ：使用 CoordinatorLayout 作为最外层布局
                        ② 在 CoordinatorLayout 中嵌套一个 AppBarLayout
                        ③ 在 AppBarLayout 中嵌套一个 CollapsingToolBarLayout
                        <com.google.android.material.appbar.CollapsingToolbarLayout
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:id="@+id/collapsing_toolbar"
                            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
                            // 指定 CollapsingToolbarLayout 折叠或趋于折叠的背景色
                            app:contentScrim="?attr/colorPrimary"
                            // scroll ：CollapsingToolbarLayout 会随着内容滚动而滚动
                            // exitUntilCollapsed ：CollapsingToolbarLayout 随着滚动完成折叠后保留在界面上不在移出屏幕
                            app:layout_scrollFlags="scroll|exitUntilCollapsed">
                        ④ 在 CollapsingToolbarLayout 中定义标题具体内容
                            app:layout_collapseMode : 指定当前控件在 CollapsingToolbarLayout 折叠过程中的折叠样式
                            “pin” ：表示保持不变
                            “parallax” ：表示产生一定的错位偏移（视觉效果较好）
                    2- 编写布局文件(水果内容详情) ：(代码参考 cardview（module）-> activity_fruit.xml)
                        ① 内容详情最外围采用 NestedScrollView 布局，它和 AppBarLayout 平级，它嵌套了响应滚动事件的功能。
                        ② 【*】 NestedScrollView 内部只允许一个直接子布局（放置多个View需要先嵌入一个ViewGroup）,案例中使用 LinearLayout
                        ③ 将 CardView 嵌套进 LinearLayout ，然后再讲显示水果名称的 TextView 嵌套在 CardView 中
                        ⑥ 【*】 卡片布局只能采用 CardView ，不能使用 MaterialCardView
                    3- 在界面上添加一个悬浮按钮
                        app:layout_anchor="@id/appBar" : 设置锚点（设定显示区域）
                        app:layout_anchorGravity="bottom|end" ：设置显示的方位，基于被设置锚点的布局
                2》编写 FruitActivity.java ，解释与代码参考 cardview（module）-> FruitActivity.java
                3》处理 RecyclerView 点击事件，当点击时打开 FruitActivity 代码参考 cardview（module）-> FruitAdapter.java
        2】充分利用系统状态栏空间
            1）将背景图和系统状态栏融合
                1》利用 android:fitsSystemWindows 属性实现，对于 CoordinatorLayout 、 AppBarLayout 、 CollapsingToolBarLayout
                这种嵌套结构中将控件的 android:fitsSystemWindows 属性设置为 true ，表示该控件会出现在系统状态栏里。
                2》对于我们的程序来说，水果栏标题中的 ImageView 因该设置为这个属性（我们需要给他的所有父布局都设置这个属性才会有效）
                3》另外，还需要将在程序中将状态栏颜色指定为透明色 ：
                    将主题中将 android:statusBar 属性的值指定为 @android:color/transparent （从API21--android 5.0 开始设置）
                    ① 在 res 下创建 values-v21(只有API高于21的系统才能读取) 目录，然后在其中创建 styles.xml 文件 (代码参考 values-v21 -> styles.xml)
                        <style name="FruitActivityTheme"
                            parent="AppTheme">
                            <item name="android:statusBarColor">@android:color/transparent</item>
                        </style>
                    ② 修改styles.xml（原），加入关于 FruitActivityTheme 的声明（保证低版本系统也能正常运行）
                        <style name="FruitActivityTheme" parent="AppTheme">
                        </style>
                4》单独给需要更改的 Activity
                    <activity android:name=".FruitActivity"
                              android:theme="@style/FruitActivityTheme">

十三、高级程序开发组件--JetPack
    1、简介 ：JetPack 是一个开发组件工具集，主要用于帮我们编写出更加简洁的代码、简化开发过程，它大部分不依赖Android系统版本，
        它的组件通常在androidx中，拥有很好的向下兼容性
        1】基础 ：基础组件可提供横向功能，例如向后兼容性，测试和Kotlin语言的支持
        2】架构 ：架构组件让设计更稳健、可测试且易维护的应用
        3】行为 ：行为组件可帮助让应用与标准Android服务（如通知、权限、分享和Google助理）相集成
        4】界面 ：界面组件可提供微件和辅助程序，让应用简单易用、有更好的体验，有助于简化界面开发
    2、ViewModule
        1】简介 ：JetPack 中最重要的组件之一，在传统开发模式下，Activity 开发任务太重，要负责逻辑处理、UI展示和网络回调，在大的项目上
            会显得臃肿并且难以维护。ViewModule  可以帮助 Activity 分担工作，它专门用于存放与界面相关的数据（界面上看得到的数据、相关变量都应该放在
            ViewModule 中）。
                 ViewModule 不会再屏幕发生旋转时重新创建（Activity会），他只会随着 Activity 退出的时候一同销毁，将界面的相关变量放在 ViewModule
            中能保证发生旋转时界面显示的数据不会丢失。
        2】简单用法
            1）添加依赖文件 ：implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'
            2）(编程规范 ： 给每一个 Activity 都创建一个 ViewModule)
                为 MainActivity 创建一个对应 MainViewModule 类，继承 ViewModule
                （代码参考 ViewModule（module）-> MainViewModule.java）
            3）获取 MainViewModule 实例，这一步很关键 ：
                MainViewModule viewModule = new ViewModelProvider(this, new ViewModelProvider.NewInstanceFactory()).get(MainViewModule.class);

                ViewModule 有独特的生命周期，要长于 Activity
























































































































































































































































































































































































































